{"ast":null,"code":"import _objectSpread from\"/Users/joshuakaufman/untitled folder 3/orchestrator/dashboard/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/**\n * Utility functions for applying action mappings to Meta API data\n *//**\n * Load action mappings from localStorage\n * @returns {Object} Action mappings object\n */export const loadActionMappings=()=>{try{const savedMappings=localStorage.getItem('meta_action_mappings');return savedMappings?JSON.parse(savedMappings):{};}catch(error){console.error('Error loading action mappings:',error);return{};}};/**\n * Apply action mappings to a single record\n * @param {Object} record - Meta API record\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Record with mapped business concepts\n */export const applyMappingsToRecord=function(record){let mappings=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(!mappings){mappings=loadActionMappings();}const mappedRecord=_objectSpread({},record);// Apply mappings to each business concept\nObject.entries(mappings).forEach(_ref=>{let[conceptName,mapping]=_ref;const{actionTypes,aggregationType}=mapping;// Calculate mapped values for actions (counts)\nconst actionValues=getActionValuesByTypes(record.actions,actionTypes);mappedRecord[\"\".concat(conceptName,\"_count\")]=aggregateValues(actionValues,aggregationType);// Calculate mapped values for action_values (monetary values)\nconst monetaryValues=getActionValuesByTypes(record.action_values,actionTypes);mappedRecord[\"\".concat(conceptName,\"_value\")]=aggregateValues(monetaryValues,aggregationType);// Calculate mapped values for conversions\nconst conversionCounts=getActionValuesByTypes(record.conversions,actionTypes);mappedRecord[\"\".concat(conceptName,\"_conversions\")]=aggregateValues(conversionCounts,aggregationType);// Calculate mapped values for conversion_values\nconst conversionValues=getActionValuesByTypes(record.conversion_values,actionTypes);mappedRecord[\"\".concat(conceptName,\"_conversion_value\")]=aggregateValues(conversionValues,aggregationType);// Store the breakdown for debugging\nmappedRecord[\"\".concat(conceptName,\"_breakdown\")]={count:actionValues,value:monetaryValues,conversions:conversionCounts,conversion_value:conversionValues};});return mappedRecord;};/**\n * Get values from action array for specific action types\n * @param {Array} actions - Array of action objects\n * @param {Array} targetActionTypes - Action types to filter for\n * @returns {Array} Array of values for matching action types\n */const getActionValuesByTypes=(actions,targetActionTypes)=>{if(!Array.isArray(actions)||!Array.isArray(targetActionTypes)){return[];}return actions.filter(action=>targetActionTypes.includes(action.action_type)).map(action=>parseFloat(action.value)||0);};/**\n * Aggregate values according to the specified aggregation type\n * @param {Array} values - Array of numeric values\n * @param {string} aggregationType - 'sum', 'count', 'average'\n * @returns {number} Aggregated value\n */const aggregateValues=(values,aggregationType)=>{if(!Array.isArray(values)||values.length===0){return 0;}switch(aggregationType){case'sum':return values.reduce((sum,val)=>sum+val,0);case'count':return values.length;case'average':return values.reduce((sum,val)=>sum+val,0)/values.length;default:return values.reduce((sum,val)=>sum+val,0);}};/**\n * Apply mappings to an array of records\n * @param {Array} records - Array of Meta API records\n * @param {Object} mappings - Action mappings configuration\n * @returns {Array} Array of records with mapped business concepts\n */export const applyMappingsToRecords=function(records){let mappings=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(!Array.isArray(records)){return records;}if(!mappings){mappings=loadActionMappings();}return records.map(record=>applyMappingsToRecord(record,mappings));};/**\n * Get summary statistics for mapped concepts across multiple records\n * @param {Array} records - Array of records with applied mappings\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Summary statistics for each concept\n */export const getMappedConceptSummary=function(records){let mappings=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(!Array.isArray(records)||records.length===0){return{};}if(!mappings){mappings=loadActionMappings();}const summary={};Object.keys(mappings).forEach(conceptName=>{const counts=records.map(r=>r[\"\".concat(conceptName,\"_count\")]||0);const values=records.map(r=>r[\"\".concat(conceptName,\"_value\")]||0);const conversions=records.map(r=>r[\"\".concat(conceptName,\"_conversions\")]||0);const conversionValues=records.map(r=>r[\"\".concat(conceptName,\"_conversion_value\")]||0);summary[conceptName]={total_count:counts.reduce((sum,val)=>sum+val,0),total_value:values.reduce((sum,val)=>sum+val,0),total_conversions:conversions.reduce((sum,val)=>sum+val,0),total_conversion_value:conversionValues.reduce((sum,val)=>sum+val,0),avg_count:counts.reduce((sum,val)=>sum+val,0)/counts.length,avg_value:values.reduce((sum,val)=>sum+val,0)/values.length,records_with_data:records.filter(r=>(r[\"\".concat(conceptName,\"_count\")]||0)>0).length};});return summary;};/**\n * Format a record for better display, including mapped concepts\n * @param {Object} record - Record with applied mappings\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Formatted record for display\n */export const formatRecordForDisplay=function(record){let mappings=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(!mappings){mappings=loadActionMappings();}const formatted=_objectSpread({},record);// Add a section for mapped business concepts\nformatted.business_metrics={};Object.keys(mappings).forEach(conceptName=>{formatted.business_metrics[conceptName]={count:record[\"\".concat(conceptName,\"_count\")]||0,value:record[\"\".concat(conceptName,\"_value\")]||0,conversions:record[\"\".concat(conceptName,\"_conversions\")]||0,conversion_value:record[\"\".concat(conceptName,\"_conversion_value\")]||0};});return formatted;};/**\n * Validate that action mappings are properly configured\n * @param {Object} mappings - Action mappings to validate\n * @returns {Object} Validation result with errors and warnings\n */export const validateActionMappings=mappings=>{const errors=[];const warnings=[];Object.entries(mappings).forEach(_ref2=>{let[conceptName,mapping]=_ref2;if(!conceptName||conceptName.trim()===''){errors.push('Concept name cannot be empty');}if(!mapping.actionTypes||!Array.isArray(mapping.actionTypes)||mapping.actionTypes.length===0){errors.push(\"Concept '\".concat(conceptName,\"' has no action types defined\"));}if(!['sum','count','average'].includes(mapping.aggregationType)){errors.push(\"Concept '\".concat(conceptName,\"' has invalid aggregation type: \").concat(mapping.aggregationType));}// Check for overlapping action types\nconst actionTypes=mapping.actionTypes;const duplicates=actionTypes.filter((item,index)=>actionTypes.indexOf(item)!==index);if(duplicates.length>0){warnings.push(\"Concept '\".concat(conceptName,\"' has duplicate action types: \").concat(duplicates.join(', ')));}});return{errors,warnings,isValid:errors.length===0};};","map":{"version":3,"names":["loadActionMappings","savedMappings","localStorage","getItem","JSON","parse","error","console","applyMappingsToRecord","record","mappings","arguments","length","undefined","mappedRecord","_objectSpread","Object","entries","forEach","_ref","conceptName","mapping","actionTypes","aggregationType","actionValues","getActionValuesByTypes","actions","concat","aggregateValues","monetaryValues","action_values","conversionCounts","conversions","conversionValues","conversion_values","count","value","conversion_value","targetActionTypes","Array","isArray","filter","action","includes","action_type","map","parseFloat","values","reduce","sum","val","applyMappingsToRecords","records","getMappedConceptSummary","summary","keys","counts","r","total_count","total_value","total_conversions","total_conversion_value","avg_count","avg_value","records_with_data","formatRecordForDisplay","formatted","business_metrics","validateActionMappings","errors","warnings","_ref2","trim","push","duplicates","item","index","indexOf","join","isValid"],"sources":["/Users/joshuakaufman/untitled folder 3/orchestrator/dashboard/client/src/components/meta/utils/actionMappingUtils.js"],"sourcesContent":["/**\n * Utility functions for applying action mappings to Meta API data\n */\n\n/**\n * Load action mappings from localStorage\n * @returns {Object} Action mappings object\n */\nexport const loadActionMappings = () => {\n  try {\n    const savedMappings = localStorage.getItem('meta_action_mappings');\n    return savedMappings ? JSON.parse(savedMappings) : {};\n  } catch (error) {\n    console.error('Error loading action mappings:', error);\n    return {};\n  }\n};\n\n/**\n * Apply action mappings to a single record\n * @param {Object} record - Meta API record\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Record with mapped business concepts\n */\nexport const applyMappingsToRecord = (record, mappings = null) => {\n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n\n  const mappedRecord = { ...record };\n  \n  // Apply mappings to each business concept\n  Object.entries(mappings).forEach(([conceptName, mapping]) => {\n    const { actionTypes, aggregationType } = mapping;\n    \n    // Calculate mapped values for actions (counts)\n    const actionValues = getActionValuesByTypes(record.actions, actionTypes);\n    mappedRecord[`${conceptName}_count`] = aggregateValues(actionValues, aggregationType);\n    \n    // Calculate mapped values for action_values (monetary values)\n    const monetaryValues = getActionValuesByTypes(record.action_values, actionTypes);\n    mappedRecord[`${conceptName}_value`] = aggregateValues(monetaryValues, aggregationType);\n    \n    // Calculate mapped values for conversions\n    const conversionCounts = getActionValuesByTypes(record.conversions, actionTypes);\n    mappedRecord[`${conceptName}_conversions`] = aggregateValues(conversionCounts, aggregationType);\n    \n    // Calculate mapped values for conversion_values\n    const conversionValues = getActionValuesByTypes(record.conversion_values, actionTypes);\n    mappedRecord[`${conceptName}_conversion_value`] = aggregateValues(conversionValues, aggregationType);\n    \n    // Store the breakdown for debugging\n    mappedRecord[`${conceptName}_breakdown`] = {\n      count: actionValues,\n      value: monetaryValues,\n      conversions: conversionCounts,\n      conversion_value: conversionValues\n    };\n  });\n  \n  return mappedRecord;\n};\n\n/**\n * Get values from action array for specific action types\n * @param {Array} actions - Array of action objects\n * @param {Array} targetActionTypes - Action types to filter for\n * @returns {Array} Array of values for matching action types\n */\nconst getActionValuesByTypes = (actions, targetActionTypes) => {\n  if (!Array.isArray(actions) || !Array.isArray(targetActionTypes)) {\n    return [];\n  }\n  \n  return actions\n    .filter(action => targetActionTypes.includes(action.action_type))\n    .map(action => parseFloat(action.value) || 0);\n};\n\n/**\n * Aggregate values according to the specified aggregation type\n * @param {Array} values - Array of numeric values\n * @param {string} aggregationType - 'sum', 'count', 'average'\n * @returns {number} Aggregated value\n */\nconst aggregateValues = (values, aggregationType) => {\n  if (!Array.isArray(values) || values.length === 0) {\n    return 0;\n  }\n  \n  switch (aggregationType) {\n    case 'sum':\n      return values.reduce((sum, val) => sum + val, 0);\n    case 'count':\n      return values.length;\n    case 'average':\n      return values.reduce((sum, val) => sum + val, 0) / values.length;\n    default:\n      return values.reduce((sum, val) => sum + val, 0);\n  }\n};\n\n/**\n * Apply mappings to an array of records\n * @param {Array} records - Array of Meta API records\n * @param {Object} mappings - Action mappings configuration\n * @returns {Array} Array of records with mapped business concepts\n */\nexport const applyMappingsToRecords = (records, mappings = null) => {\n  if (!Array.isArray(records)) {\n    return records;\n  }\n  \n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  \n  return records.map(record => applyMappingsToRecord(record, mappings));\n};\n\n/**\n * Get summary statistics for mapped concepts across multiple records\n * @param {Array} records - Array of records with applied mappings\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Summary statistics for each concept\n */\nexport const getMappedConceptSummary = (records, mappings = null) => {\n  if (!Array.isArray(records) || records.length === 0) {\n    return {};\n  }\n  \n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  \n  const summary = {};\n  \n  Object.keys(mappings).forEach(conceptName => {\n    const counts = records.map(r => r[`${conceptName}_count`] || 0);\n    const values = records.map(r => r[`${conceptName}_value`] || 0);\n    const conversions = records.map(r => r[`${conceptName}_conversions`] || 0);\n    const conversionValues = records.map(r => r[`${conceptName}_conversion_value`] || 0);\n    \n    summary[conceptName] = {\n      total_count: counts.reduce((sum, val) => sum + val, 0),\n      total_value: values.reduce((sum, val) => sum + val, 0),\n      total_conversions: conversions.reduce((sum, val) => sum + val, 0),\n      total_conversion_value: conversionValues.reduce((sum, val) => sum + val, 0),\n      avg_count: counts.reduce((sum, val) => sum + val, 0) / counts.length,\n      avg_value: values.reduce((sum, val) => sum + val, 0) / values.length,\n      records_with_data: records.filter(r => (r[`${conceptName}_count`] || 0) > 0).length\n    };\n  });\n  \n  return summary;\n};\n\n/**\n * Format a record for better display, including mapped concepts\n * @param {Object} record - Record with applied mappings\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Formatted record for display\n */\nexport const formatRecordForDisplay = (record, mappings = null) => {\n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  \n  const formatted = { ...record };\n  \n  // Add a section for mapped business concepts\n  formatted.business_metrics = {};\n  \n  Object.keys(mappings).forEach(conceptName => {\n    formatted.business_metrics[conceptName] = {\n      count: record[`${conceptName}_count`] || 0,\n      value: record[`${conceptName}_value`] || 0,\n      conversions: record[`${conceptName}_conversions`] || 0,\n      conversion_value: record[`${conceptName}_conversion_value`] || 0\n    };\n  });\n  \n  return formatted;\n};\n\n/**\n * Validate that action mappings are properly configured\n * @param {Object} mappings - Action mappings to validate\n * @returns {Object} Validation result with errors and warnings\n */\nexport const validateActionMappings = (mappings) => {\n  const errors = [];\n  const warnings = [];\n  \n  Object.entries(mappings).forEach(([conceptName, mapping]) => {\n    if (!conceptName || conceptName.trim() === '') {\n      errors.push('Concept name cannot be empty');\n    }\n    \n    if (!mapping.actionTypes || !Array.isArray(mapping.actionTypes) || mapping.actionTypes.length === 0) {\n      errors.push(`Concept '${conceptName}' has no action types defined`);\n    }\n    \n    if (!['sum', 'count', 'average'].includes(mapping.aggregationType)) {\n      errors.push(`Concept '${conceptName}' has invalid aggregation type: ${mapping.aggregationType}`);\n    }\n    \n    // Check for overlapping action types\n    const actionTypes = mapping.actionTypes;\n    const duplicates = actionTypes.filter((item, index) => actionTypes.indexOf(item) !== index);\n    if (duplicates.length > 0) {\n      warnings.push(`Concept '${conceptName}' has duplicate action types: ${duplicates.join(', ')}`);\n    }\n  });\n  \n  return { errors, warnings, isValid: errors.length === 0 };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}