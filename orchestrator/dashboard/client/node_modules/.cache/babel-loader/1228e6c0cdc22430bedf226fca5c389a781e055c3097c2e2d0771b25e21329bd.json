{"ast":null,"code":"import axios from 'axios';\n\n// Base URL for API requests - updated to use localhost:5001 consistently\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5001';\n\n// Create an axios instance\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  // Increase timeout for large responses\n  timeout: 600000,\n  // 10 minutes\n  // Set max content length to 500MB\n  maxContentLength: 500 * 1024 * 1024,\n  maxBodyLength: 500 * 1024 * 1024\n});\n\n// Add response interceptor to handle large responses\napiClient.interceptors.response.use(response => {\n  // Log response size for debugging\n  if (response.data) {\n    const responseSize = JSON.stringify(response.data).length;\n    if (responseSize > 10 * 1024 * 1024) {\n      // 10MB+\n      console.warn(`Large API response: ${(responseSize / (1024 * 1024)).toFixed(2)} MB`);\n    }\n  }\n  return response;\n}, error => {\n  var _error$message, _error$message2;\n  // Enhanced error handling for memory issues\n  if (error.code === 'ERR_INSUFFICIENT_RESOURCES' || (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('out of memory') || (_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('Maximum call stack')) {\n    console.error('Response too large for browser to handle:', error);\n    error.message = 'Response is too large for your browser to handle. Please use debug mode or reduce the date range.';\n  }\n  return Promise.reject(error);\n});\nexport const api = {\n  // Mixpanel Debug Endpoints\n\n  /**\n   * Get raw Mixpanel data with filters\n   * @param {Object} params - Query parameters\n   * @returns {Promise<Object>} - Response data\n   */\n  getRawMixpanelData: async (params = {}) => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/data', {\n        params\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching Mixpanel data:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get the last Mixpanel data load timestamp\n   * @returns {Promise<Object>} - Response with timestamp\n   */\n  getMixpanelDebugSyncTS: async () => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/sync-ts');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching Mixpanel sync timestamp:', error);\n      throw error;\n    }\n  },\n  /**\n   * Reset the last Mixpanel data load timestamp\n   * @returns {Promise<Object>} - Response with success message\n   */\n  resetMixpanelDebugSyncTS: async () => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/debug/sync-ts/reset');\n      return response.data;\n    } catch (error) {\n      console.error('Error resetting Mixpanel sync timestamp:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get the latest processed date to continue from\n   * @returns {Promise<Object>} - Response with latest processed date info\n   */\n  getLatestProcessedDate: async () => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/latest-processed-date');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching latest processed date:', error);\n      throw error;\n    }\n  },\n  /**\n   * Reset all Mixpanel data in the database\n   * @returns {Promise<Object>} - Response with success message\n   */\n  resetMixpanelDatabase: async () => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/debug/database/reset');\n      return response.data;\n    } catch (error) {\n      console.error('Error resetting Mixpanel database:', error);\n      throw error;\n    }\n  },\n  /**\n   * Refresh Mixpanel data by clearing data directories\n   * @returns {Promise<Object>} - Response with success message\n   */\n  refreshMixpanelData: async () => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/debug/data/refresh');\n      return response.data;\n    } catch (error) {\n      console.error('Error refreshing Mixpanel data:', error);\n      throw error;\n    }\n  },\n  /**\n   * Trigger Mixpanel data ingestion\n   * @param {string} startDate - Optional start date (YYYY-MM-DD)\n   * @returns {Promise<Object>} - Response with success message\n   */\n  triggerMixpanelIngest: async startDate => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/ingest', null, {\n        params: startDate ? {\n          start_date: startDate\n        } : {}\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error triggering data ingest:', error);\n      throw error;\n    }\n  },\n  /**\n   * Start the Mixpanel data processing pipeline\n   * @param {Object} options - Processing options\n   * @param {string} options.start_date - Start date (YYYY-MM-DD)\n   * @param {boolean} options.wipe_folder - Whether to wipe the folder before processing\n   * @returns {Promise<Object>} - Response with success status\n   */\n  startMixpanelProcessing: async options => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/process/start', options);\n      return response.data;\n    } catch (error) {\n      console.error('Error starting Mixpanel processing:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get the current status of Mixpanel data processing\n   * @returns {Promise<Object>} - Response with processing status\n   */\n  getMixpanelProcessStatus: async () => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/process/status');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching process status:', error);\n      throw error;\n    }\n  },\n  /**\n   * Cancel the current Mixpanel data processing job\n   * @returns {Promise<Object>} - Response with success status\n   */\n  cancelMixpanelProcessing: async () => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/process/cancel');\n      return response.data;\n    } catch (error) {\n      console.error('Error canceling processing:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get test DB user data\n   * @param {string} distinctId - Optional user distinct ID\n   * @returns {Promise<Object>} - Response with user data\n   */\n  getTestDbUser: async distinctId => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/test-db-user', {\n        params: distinctId ? {\n          distinct_id: distinctId\n        } : {}\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching test DB user:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get test DB events data\n   * @param {string} distinctId - Optional user distinct ID\n   * @returns {Promise<Object>} - Response with events data\n   */\n  getTestDbEvents: async distinctId => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/test-db-events', {\n        params: distinctId ? {\n          distinct_id: distinctId\n        } : {}\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching test DB events:', error);\n      throw error;\n    }\n  },\n  /**\n   * Fetch Meta API data\n   * @param {Object} params - Request parameters\n   * @param {string} params.start_date - Start date (YYYY-MM-DD)\n   * @param {string} params.end_date - End date (YYYY-MM-DD)\n   * @param {number} params.time_increment - Time increment in days\n   * @param {string} [params.fields] - Comma-separated list of fields to retrieve\n   * @returns {Promise<Object>} - Response with Meta API data\n   */\n  fetchMetaData: async params => {\n    try {\n      const response = await apiClient.post('/api/meta/fetch', params);\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching Meta API data:', error);\n      throw error;\n    }\n  },\n  /**\n   * Check the status of an async Meta API job\n   * @param {string} reportRunId - The report run ID\n   * @returns {Promise<Object>} - Job status information\n   */\n  checkMetaJobStatus: async reportRunId => {\n    try {\n      const response = await apiClient.get(`/api/meta/job/${reportRunId}/status`);\n      return response.data;\n    } catch (error) {\n      console.error('Error checking Meta job status:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get results from a completed async Meta API job\n   * @param {string} reportRunId - The report run ID\n   * @param {boolean} useFileUrl - Whether to use file URL download\n   * @returns {Promise<Object>} - Job results\n   */\n  getMetaJobResults: async (reportRunId, useFileUrl = false) => {\n    try {\n      const response = await apiClient.get(`/api/meta/job/${reportRunId}/results`, {\n        params: {\n          use_file_url: useFileUrl\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting Meta job results:', error);\n      throw error;\n    }\n  },\n  // --- Cohort Analyzer API Methods ---\n  analyzeCohortData: async filters => {\n    try {\n      const response = await apiClient.post('/api/cohort-analysis', filters);\n      return response.data;\n    } catch (error) {\n      var _error$response, _error$response2;\n      console.error('Error analyzing cohort data:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n      throw ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.data) || error;\n    }\n  },\n  // --- Cohort Analyzer V3 API Methods ---\n  analyzeCohortDataV3: async filters => {\n    try {\n      console.log('[V3] Sending cohort analysis request to V3 API:', filters);\n      const response = await apiClient.post('/api/v3/cohort/analyze', filters);\n      console.log('[V3] Received response from V3 API:', response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response3, _error$response4;\n      console.error('Error analyzing cohort data with V3 API:', ((_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.data) || error.message);\n      throw ((_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.data) || error;\n    }\n  },\n  analyzeCohortDataV3Enhanced: async filters => {\n    try {\n      console.log('[V3] Sending enhanced cohort analysis request to V3 API:', filters);\n      const response = await apiClient.post('/api/v3/cohort/analyze-enhanced', filters);\n      console.log('[V3] Received enhanced response from V3 API:', response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response5, _error$response6;\n      console.error('Error analyzing cohort data with V3 Enhanced API:', ((_error$response5 = error.response) === null || _error$response5 === void 0 ? void 0 : _error$response5.data) || error.message);\n      throw ((_error$response6 = error.response) === null || _error$response6 === void 0 ? void 0 : _error$response6.data) || error;\n    }\n  },\n  // --- Cohort Analyzer V3 Refactored API Methods ---\n  analyzeCohortDataV3Refactored: async filters => {\n    try {\n      console.log('[V3-Refactored] Sending cohort analysis request to V3 Refactored API:', filters);\n      const response = await apiClient.post('/api/v3/cohort/analyze-refactored', filters);\n      console.log('[V3-Refactored] Received response from V3 Refactored API:', response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response7, _error$response8;\n      console.error('Error analyzing cohort data with V3 Refactored API:', ((_error$response7 = error.response) === null || _error$response7 === void 0 ? void 0 : _error$response7.data) || error.message);\n      throw ((_error$response8 = error.response) === null || _error$response8 === void 0 ? void 0 : _error$response8.data) || error;\n    }\n  },\n  getV3RefactoredHealth: async () => {\n    try {\n      const response = await apiClient.get('/api/v3/cohort/refactored-health');\n      return response.data;\n    } catch (error) {\n      var _error$response9, _error$response0;\n      console.error('Error checking V3 Refactored health:', ((_error$response9 = error.response) === null || _error$response9 === void 0 ? void 0 : _error$response9.data) || error.message);\n      throw ((_error$response0 = error.response) === null || _error$response0 === void 0 ? void 0 : _error$response0.data) || error;\n    }\n  },\n  getV3RefactoredVersion: async () => {\n    try {\n      const response = await apiClient.get('/api/v3/cohort/refactored-version');\n      return response.data;\n    } catch (error) {\n      var _error$response1, _error$response10;\n      console.error('Error getting V3 Refactored version:', ((_error$response1 = error.response) === null || _error$response1 === void 0 ? void 0 : _error$response1.data) || error.message);\n      throw ((_error$response10 = error.response) === null || _error$response10 === void 0 ? void 0 : _error$response10.data) || error;\n    }\n  },\n  // V3 Refactored Debug Methods\n  runV3RefactoredStageAnalysis: async (filters, stage) => {\n    try {\n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] CALLING runV3RefactoredStageAnalysis for stage: ${stage}`);\n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] Will POST to: /api/v3/cohort/analyze-refactored`);\n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] Filters:`, filters);\n      const debugFilters = {\n        ...filters,\n        debug_mode: true,\n        debug_stage: stage,\n        pipeline_version: '3.0.0_refactored'\n      };\n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] Final payload:`, debugFilters);\n      const response = await apiClient.post('/api/v3/cohort/analyze-refactored', debugFilters);\n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] SUCCESS! Received response:`, response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response11, _error$response12;\n      console.error(`ðŸš¨ðŸš¨ðŸš¨ [V3-REFACTORED API] ERROR in stage ${stage} analysis:`, ((_error$response11 = error.response) === null || _error$response11 === void 0 ? void 0 : _error$response11.data) || error.message);\n      throw ((_error$response12 = error.response) === null || _error$response12 === void 0 ? void 0 : _error$response12.data) || error;\n    }\n  },\n  getV3Health: async () => {\n    try {\n      const response = await apiClient.get('/api/v3/cohort/health');\n      return response.data;\n    } catch (error) {\n      var _error$response13, _error$response14;\n      console.error('Error checking V3 health:', ((_error$response13 = error.response) === null || _error$response13 === void 0 ? void 0 : _error$response13.data) || error.message);\n      throw ((_error$response14 = error.response) === null || _error$response14 === void 0 ? void 0 : _error$response14.data) || error;\n    }\n  },\n  getV3Version: async () => {\n    try {\n      const response = await apiClient.get('/api/v3/cohort/version');\n      return response.data;\n    } catch (error) {\n      var _error$response15, _error$response16;\n      console.error('Error getting V3 version:', ((_error$response15 = error.response) === null || _error$response15 === void 0 ? void 0 : _error$response15.data) || error.message);\n      throw ((_error$response16 = error.response) === null || _error$response16 === void 0 ? void 0 : _error$response16.data) || error;\n    }\n  },\n  getCohortUserTimeline: async filters => {\n    try {\n      console.log('[DEBUG] getCohortUserTimeline called with filters:', filters);\n      // Convert optional_filters to legacy format for the unified pipeline\n      const optional_filters = filters.optional_filters || [];\n      let primary_user_filter = {};\n      let secondary_filters = [];\n      if (optional_filters.length > 0) {\n        // Convert optional_filters to legacy format\n        const user_filters = optional_filters.filter(f => f.property_source === 'user');\n        const event_filters = optional_filters.filter(f => f.property_source === 'event');\n\n        // Use the first user filter as primary_user_filter\n        primary_user_filter = user_filters.length > 0 ? user_filters[0] : {};\n\n        // Only event filters go to secondary_filters\n        secondary_filters = event_filters;\n      } else {\n        // Fall back to legacy format if provided\n        primary_user_filter = filters.primary_user_filter || {};\n        secondary_filters = filters.secondary_filters || [];\n      }\n      const payload = {\n        date_from: filters.date_from_str,\n        date_to: filters.date_to_str,\n        primary_user_filter: primary_user_filter,\n        secondary_filters: secondary_filters,\n        config: {}\n      };\n      console.log('[DEBUG] getCohortUserTimeline sending payload:', payload);\n      const response = await apiClient.post('/api/cohort-pipeline/timeline', payload);\n      console.log('[DEBUG] getCohortUserTimeline received response:', response.data);\n      return response.data;\n    } catch (error) {\n      var _error$response17, _error$response18;\n      console.error('Error fetching cohort user timeline:', ((_error$response17 = error.response) === null || _error$response17 === void 0 ? void 0 : _error$response17.data) || error.message);\n      console.error('[DEBUG] getCohortUserTimeline full error:', error);\n      throw ((_error$response18 = error.response) === null || _error$response18 === void 0 ? void 0 : _error$response18.data) || error;\n    }\n  },\n  getUserEventRevenueTimeline: async (filters, distinctId = null, productId = null) => {\n    try {\n      var _v3Data$stage_results;\n      console.log('[DEBUG] getUserEventRevenueTimeline called with filters:', filters, 'distinctId:', distinctId, 'productId:', productId);\n\n      // CRITICAL FIX: Use V3 API instead of legacy API\n      // The legacy API has the business logic bug where trial conversions incorrectly set initial_purchase = 1\n      // The V3 API uses the correct EventStateTracker that properly handles business rules\n\n      // Convert filters to V3 format\n      const v3Payload = {\n        date_from_str: filters.date_from_str,\n        date_to_str: filters.date_to_str,\n        // Convert optional_filters to V3 user_filters format\n        user_filters: []\n      };\n\n      // Handle filter conversion\n      if (filters.optional_filters && filters.optional_filters.length > 0) {\n        // Use optional_filters (new format)\n        v3Payload.user_filters = filters.optional_filters.filter(f => f.property_source === 'user');\n      } else if (filters.primary_user_filter && filters.primary_user_filter.property_name) {\n        // Convert legacy primary_user_filter format\n        v3Payload.user_filters = [{\n          property_name: filters.primary_user_filter.property_name,\n          property_values: filters.primary_user_filter.property_values,\n          property_source: 'user'\n        }];\n      }\n\n      // Add user/product filtering if specified\n      if (distinctId) v3Payload.distinct_id = distinctId;\n      if (productId) v3Payload.product_id = productId;\n      console.log('[DEBUG] getUserEventRevenueTimeline sending V3 payload:', v3Payload);\n\n      // Use V3 API endpoint that has correct business logic\n      const response = await apiClient.post('/api/v3/cohort/analyze-refactored', v3Payload);\n      console.log('[DEBUG] getUserEventRevenueTimeline received V3 response:', response.data);\n\n      // Convert V3 response to legacy format for compatibility with existing frontend code\n      const v3Data = response.data;\n      const stage3Data = v3Data === null || v3Data === void 0 ? void 0 : (_v3Data$stage_results = v3Data.stage_results) === null || _v3Data$stage_results === void 0 ? void 0 : _v3Data$stage_results.stage3;\n      if (!stage3Data || !stage3Data.timeline_results) {\n        throw new Error('Invalid V3 response format');\n      }\n      const timelineResults = stage3Data.timeline_results;\n\n      // Convert V3 timeline data to legacy format\n      const legacyFormat = {\n        dates: timelineResults.dates || [],\n        event_rows: {},\n        estimate_rows: {},\n        arpc_per_product: timelineResults.arpc_per_product || {},\n        available_users: Object.keys(timelineResults.user_daily_metrics || {}),\n        available_products: timelineResults.available_products || []\n      };\n\n      // Convert daily metrics to legacy event_rows format\n      if (timelineResults.timeline_data) {\n        legacyFormat.dates.forEach(date => {\n          const dayData = timelineResults.timeline_data[date] || {};\n\n          // Map V3 field names to legacy field names\n          if (!legacyFormat.event_rows.trial_started) legacyFormat.event_rows.trial_started = {};\n          if (!legacyFormat.event_rows.trial_pending) legacyFormat.event_rows.trial_pending = {};\n          if (!legacyFormat.event_rows.trial_ended) legacyFormat.event_rows.trial_ended = {};\n          if (!legacyFormat.event_rows.trial_converted) legacyFormat.event_rows.trial_converted = {};\n          if (!legacyFormat.event_rows.trial_canceled) legacyFormat.event_rows.trial_canceled = {};\n          if (!legacyFormat.event_rows.initial_purchase) legacyFormat.event_rows.initial_purchase = {};\n          if (!legacyFormat.event_rows.subscription_active) legacyFormat.event_rows.subscription_active = {};\n          if (!legacyFormat.event_rows.subscription_cancelled) legacyFormat.event_rows.subscription_cancelled = {};\n          if (!legacyFormat.event_rows.refund) legacyFormat.event_rows.refund = {};\n          legacyFormat.event_rows.trial_started[date] = dayData.trial_started || 0;\n          legacyFormat.event_rows.trial_pending[date] = dayData.trial_pending || 0;\n          legacyFormat.event_rows.trial_ended[date] = dayData.trial_ended || 0;\n          legacyFormat.event_rows.trial_converted[date] = dayData.trial_converted || 0;\n          legacyFormat.event_rows.trial_canceled[date] = dayData.trial_cancelled || 0; // Note: cancelled vs canceled\n          legacyFormat.event_rows.initial_purchase[date] = dayData.initial_purchase || 0; // CRITICAL: This will now be 0 for trial conversions\n          legacyFormat.event_rows.subscription_active[date] = dayData.subscription_active || 0;\n          legacyFormat.event_rows.subscription_cancelled[date] = dayData.subscription_cancelled || 0;\n          legacyFormat.event_rows.refund[date] = dayData.refund_count || 0;\n\n          // Revenue data\n          if (!legacyFormat.estimate_rows.current_revenue) legacyFormat.estimate_rows.current_revenue = {};\n          if (!legacyFormat.estimate_rows.estimated_revenue) legacyFormat.estimate_rows.estimated_revenue = {};\n          if (!legacyFormat.estimate_rows.estimated_net_revenue) legacyFormat.estimate_rows.estimated_net_revenue = {};\n          legacyFormat.estimate_rows.current_revenue[date] = dayData.revenue || 0;\n          legacyFormat.estimate_rows.estimated_revenue[date] = dayData.estimated_revenue || 0;\n          legacyFormat.estimate_rows.estimated_net_revenue[date] = dayData.estimated_revenue || 0;\n        });\n      }\n\n      // Add cumulative data for legacy compatibility\n      legacyFormat.event_rows.cumulative_initial_purchase = {};\n      let cumulativeInitialPurchase = 0;\n      legacyFormat.dates.forEach(date => {\n        cumulativeInitialPurchase += legacyFormat.event_rows.initial_purchase[date] || 0;\n        legacyFormat.event_rows.cumulative_initial_purchase[date] = cumulativeInitialPurchase;\n      });\n      console.log('[DEBUG] getUserEventRevenueTimeline converted to legacy format:', legacyFormat);\n      return legacyFormat;\n    } catch (err) {\n      console.error('getUserEventRevenueTimeline error:', err);\n      throw err;\n    }\n  },\n  getDiscoverableCohortProperties: async () => {\n    try {\n      const response = await apiClient.get('/api/cohort_analyzer/discoverable_properties');\n      return response.data;\n    } catch (error) {\n      var _error$response19, _error$response20;\n      console.error('Error fetching discoverable cohort properties:', ((_error$response19 = error.response) === null || _error$response19 === void 0 ? void 0 : _error$response19.data) || error.message);\n      throw ((_error$response20 = error.response) === null || _error$response20 === void 0 ? void 0 : _error$response20.data) || error;\n    }\n  },\n  getDiscoverableCohortPropertyValues: async (propertyKey, propertySource) => {\n    try {\n      const response = await apiClient.get('/api/cohort_analyzer/property_values', {\n        params: {\n          property_key: propertyKey,\n          property_source: propertySource\n        }\n      });\n      return response.data;\n    } catch (error) {\n      var _error$response21, _error$response22;\n      console.error(`Error fetching values for ${propertyKey} (${propertySource}):`, ((_error$response21 = error.response) === null || _error$response21 === void 0 ? void 0 : _error$response21.data) || error.message);\n      throw ((_error$response22 = error.response) === null || _error$response22 === void 0 ? void 0 : _error$response22.data) || error;\n    }\n  },\n  triggerCohortPropertyDiscovery: async () => {\n    try {\n      const response = await apiClient.post('/api/cohort_analyzer/trigger_discovery');\n      return response.data;\n    } catch (error) {\n      var _error$response23, _error$response24;\n      console.error('Error triggering cohort property discovery:', ((_error$response23 = error.response) === null || _error$response23 === void 0 ? void 0 : _error$response23.data) || error.message);\n      throw ((_error$response24 = error.response) === null || _error$response24 === void 0 ? void 0 : _error$response24.data) || error;\n    }\n  },\n  enableCohortProperties: async () => {\n    try {\n      const response = await apiClient.post('/api/cohort_analyzer/enable_properties');\n      return response.data;\n    } catch (error) {\n      var _error$response25, _error$response26;\n      console.error('Error enabling cohort properties:', ((_error$response25 = error.response) === null || _error$response25 === void 0 ? void 0 : _error$response25.data) || error.message);\n      throw ((_error$response26 = error.response) === null || _error$response26 === void 0 ? void 0 : _error$response26.data) || error;\n    }\n  },\n  getPropertyDiscoveryStatus: async () => {\n    try {\n      const response = await apiClient.get('/api/cohort_analyzer/discovery_status');\n      return response.data;\n    } catch (error) {\n      var _error$response27, _error$response28;\n      console.error('Error checking property discovery status:', ((_error$response27 = error.response) === null || _error$response27 === void 0 ? void 0 : _error$response27.data) || error.message);\n      throw ((_error$response28 = error.response) === null || _error$response28 === void 0 ? void 0 : _error$response28.data) || error;\n    }\n  },\n  // --- Mixpanel Debug API Methods ---\n  getMixpanelDatabaseStats: async () => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/database-stats');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching Mixpanel database statistics:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get events for a specific user\n   * @param {string} userId - User ID or distinct ID\n   * @returns {Promise<Array>} - Response with user events\n   */\n  getUserEvents: async userId => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/user-events', {\n        params: {\n          user_id: userId\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching user events:', error);\n      throw error;\n    }\n  },\n  // --- Meta Historical Data API Methods ---\n\n  /**\n   * Start a historical data collection job\n   * @param {Object} params - Collection parameters\n   * @param {string} params.start_date - Start date (YYYY-MM-DD)\n   * @param {string} params.end_date - End date (YYYY-MM-DD)\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @returns {Promise<Object>} - Response with job ID\n   */\n  startHistoricalCollection: async params => {\n    try {\n      const response = await apiClient.post('/api/meta/historical/start', params);\n      return response.data;\n    } catch (error) {\n      console.error('Error starting historical collection:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get status of a historical collection job\n   * @param {string} jobId - Job ID\n   * @returns {Promise<Object>} - Job status information\n   */\n  getHistoricalJobStatus: async jobId => {\n    try {\n      const response = await apiClient.get(`/api/meta/historical/jobs/${jobId}/status`);\n      return response.data;\n    } catch (error) {\n      console.error('Error getting job status:', error);\n      throw error;\n    }\n  },\n  /**\n   * Cancel a historical collection job\n   * @param {string} jobId - Job ID\n   * @returns {Promise<Object>} - Cancellation confirmation\n   */\n  cancelHistoricalJob: async jobId => {\n    try {\n      const response = await apiClient.post(`/api/meta/historical/jobs/${jobId}/cancel`);\n      return response.data;\n    } catch (error) {\n      console.error('Error cancelling job:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get data coverage summary for a configuration\n   * @param {Object} params - Configuration parameters\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @param {string} [params.start_date] - Optional start date filter\n   * @param {string} [params.end_date] - Optional end date filter\n   * @returns {Promise<Object>} - Coverage summary\n   */\n  getDataCoverage: async params => {\n    try {\n      const response = await apiClient.get('/api/meta/historical/coverage', {\n        params\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting data coverage:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get list of missing dates for a configuration\n   * @param {Object} params - Configuration parameters\n   * @param {string} params.start_date - Start date (YYYY-MM-DD)\n   * @param {string} params.end_date - End date (YYYY-MM-DD)\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @returns {Promise<Object>} - Missing dates information\n   */\n  getMissingDates: async params => {\n    try {\n      const response = await apiClient.get('/api/meta/historical/missing-dates', {\n        params\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting missing dates:', error);\n      throw error;\n    }\n  },\n  /**\n   * Delete all data for a specific historical configuration\n   * @param {string} configHash - Configuration hash to delete\n   * @returns {Promise<Object>} - Deletion confirmation\n   */\n  deleteHistoricalConfiguration: async configHash => {\n    try {\n      const response = await apiClient.delete(`/api/meta/historical/configurations/${configHash}`);\n      return response.data;\n    } catch (error) {\n      console.error('Error deleting historical configuration:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get all stored request configurations\n   * @returns {Promise<Array>} - List of configurations\n   */\n  getHistoricalConfigurations: async () => {\n    try {\n      const response = await apiClient.get('/api/meta/historical/configurations');\n      return response.data;\n    } catch (error) {\n      console.error('Error getting configurations:', error);\n      throw error;\n    }\n  },\n  /**\n   * Export stored data for a configuration and date range\n   * @param {Object} params - Export parameters\n   * @param {string} params.start_date - Start date (YYYY-MM-DD)\n   * @param {string} params.end_date - End date (YYYY-MM-DD)\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @param {string} [params.format] - Export format (default: 'json')\n   * @returns {Promise<Object>} - Exported data\n   */\n  exportHistoricalData: async params => {\n    try {\n      const response = await apiClient.get('/api/meta/historical/export', {\n        params\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error exporting data:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get stored data for a specific day and configuration\n   * @param {Object} params - Day data parameters\n   * @param {string} params.date - Date (YYYY-MM-DD)\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @returns {Promise<Object>} - Day data\n   */\n  getHistoricalDayData: async params => {\n    try {\n      const response = await apiClient.post('/api/meta/historical/get-day-data', params);\n      return response.data;\n    } catch (error) {\n      console.error('Error getting day data:', error);\n      throw error;\n    }\n  },\n  /**\n   * Get current action mappings\n   * @returns {Promise<Object>} - Action mappings\n   */\n  getActionMappings: async () => {\n    try {\n      const response = await apiClient.get('/api/meta/action-mappings');\n      return response.data;\n    } catch (error) {\n      console.error('Error getting action mappings:', error);\n      throw error;\n    }\n  },\n  /**\n   * Save action mappings\n   * @param {Object} mappings - Action mappings to save\n   * @returns {Promise<Object>} - Save confirmation\n   */\n  saveActionMappings: async mappings => {\n    try {\n      const response = await apiClient.post('/api/meta/action-mappings', {\n        mappings\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error saving action mappings:', error);\n      throw error;\n    }\n  }\n};","map":{"version":3,"names":["axios","API_BASE_URL","process","env","REACT_APP_API_URL","apiClient","create","baseURL","headers","timeout","maxContentLength","maxBodyLength","interceptors","response","use","data","responseSize","JSON","stringify","length","console","warn","toFixed","error","_error$message","_error$message2","code","message","includes","Promise","reject","api","getRawMixpanelData","params","get","getMixpanelDebugSyncTS","resetMixpanelDebugSyncTS","post","getLatestProcessedDate","resetMixpanelDatabase","refreshMixpanelData","triggerMixpanelIngest","startDate","start_date","startMixpanelProcessing","options","getMixpanelProcessStatus","cancelMixpanelProcessing","getTestDbUser","distinctId","distinct_id","getTestDbEvents","fetchMetaData","checkMetaJobStatus","reportRunId","getMetaJobResults","useFileUrl","use_file_url","analyzeCohortData","filters","_error$response","_error$response2","analyzeCohortDataV3","log","_error$response3","_error$response4","analyzeCohortDataV3Enhanced","_error$response5","_error$response6","analyzeCohortDataV3Refactored","_error$response7","_error$response8","getV3RefactoredHealth","_error$response9","_error$response0","getV3RefactoredVersion","_error$response1","_error$response10","runV3RefactoredStageAnalysis","stage","debugFilters","debug_mode","debug_stage","pipeline_version","_error$response11","_error$response12","getV3Health","_error$response13","_error$response14","getV3Version","_error$response15","_error$response16","getCohortUserTimeline","optional_filters","primary_user_filter","secondary_filters","user_filters","filter","f","property_source","event_filters","payload","date_from","date_from_str","date_to","date_to_str","config","_error$response17","_error$response18","getUserEventRevenueTimeline","productId","_v3Data$stage_results","v3Payload","property_name","property_values","product_id","v3Data","stage3Data","stage_results","stage3","timeline_results","Error","timelineResults","legacyFormat","dates","event_rows","estimate_rows","arpc_per_product","available_users","Object","keys","user_daily_metrics","available_products","timeline_data","forEach","date","dayData","trial_started","trial_pending","trial_ended","trial_converted","trial_canceled","initial_purchase","subscription_active","subscription_cancelled","refund","trial_cancelled","refund_count","current_revenue","estimated_revenue","estimated_net_revenue","revenue","cumulative_initial_purchase","cumulativeInitialPurchase","err","getDiscoverableCohortProperties","_error$response19","_error$response20","getDiscoverableCohortPropertyValues","propertyKey","propertySource","property_key","_error$response21","_error$response22","triggerCohortPropertyDiscovery","_error$response23","_error$response24","enableCohortProperties","_error$response25","_error$response26","getPropertyDiscoveryStatus","_error$response27","_error$response28","getMixpanelDatabaseStats","getUserEvents","userId","user_id","startHistoricalCollection","getHistoricalJobStatus","jobId","cancelHistoricalJob","getDataCoverage","getMissingDates","deleteHistoricalConfiguration","configHash","delete","getHistoricalConfigurations","exportHistoricalData","getHistoricalDayData","getActionMappings","saveActionMappings","mappings"],"sources":["/Users/joshuakaufman/untitled folder 3/orchestrator/dashboard/client/src/services/api.js"],"sourcesContent":["import axios from 'axios';\n\n// Base URL for API requests - updated to use localhost:5001 consistently\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5001';\n\n// Create an axios instance\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  // Increase timeout for large responses\n  timeout: 600000, // 10 minutes\n  // Set max content length to 500MB\n  maxContentLength: 500 * 1024 * 1024,\n  maxBodyLength: 500 * 1024 * 1024,\n});\n\n// Add response interceptor to handle large responses\napiClient.interceptors.response.use(\n  (response) => {\n    // Log response size for debugging\n    if (response.data) {\n      const responseSize = JSON.stringify(response.data).length;\n      if (responseSize > 10 * 1024 * 1024) { // 10MB+\n        console.warn(`Large API response: ${(responseSize / (1024 * 1024)).toFixed(2)} MB`);\n      }\n    }\n    return response;\n  },\n  (error) => {\n    // Enhanced error handling for memory issues\n    if (error.code === 'ERR_INSUFFICIENT_RESOURCES' || \n        error.message?.includes('out of memory') ||\n        error.message?.includes('Maximum call stack')) {\n      console.error('Response too large for browser to handle:', error);\n      error.message = 'Response is too large for your browser to handle. Please use debug mode or reduce the date range.';\n    }\n    return Promise.reject(error);\n  }\n);\n\nexport const api = {\n  // Mixpanel Debug Endpoints\n  \n  /**\n   * Get raw Mixpanel data with filters\n   * @param {Object} params - Query parameters\n   * @returns {Promise<Object>} - Response data\n   */\n  getRawMixpanelData: async (params = {}) => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/data', { params });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching Mixpanel data:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get the last Mixpanel data load timestamp\n   * @returns {Promise<Object>} - Response with timestamp\n   */\n  getMixpanelDebugSyncTS: async () => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/sync-ts');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching Mixpanel sync timestamp:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Reset the last Mixpanel data load timestamp\n   * @returns {Promise<Object>} - Response with success message\n   */\n  resetMixpanelDebugSyncTS: async () => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/debug/sync-ts/reset');\n      return response.data;\n    } catch (error) {\n      console.error('Error resetting Mixpanel sync timestamp:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get the latest processed date to continue from\n   * @returns {Promise<Object>} - Response with latest processed date info\n   */\n  getLatestProcessedDate: async () => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/latest-processed-date');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching latest processed date:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Reset all Mixpanel data in the database\n   * @returns {Promise<Object>} - Response with success message\n   */\n  resetMixpanelDatabase: async () => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/debug/database/reset');\n      return response.data;\n    } catch (error) {\n      console.error('Error resetting Mixpanel database:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Refresh Mixpanel data by clearing data directories\n   * @returns {Promise<Object>} - Response with success message\n   */\n  refreshMixpanelData: async () => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/debug/data/refresh');\n      return response.data;\n    } catch (error) {\n      console.error('Error refreshing Mixpanel data:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Trigger Mixpanel data ingestion\n   * @param {string} startDate - Optional start date (YYYY-MM-DD)\n   * @returns {Promise<Object>} - Response with success message\n   */\n  triggerMixpanelIngest: async (startDate) => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/ingest', null, {\n        params: startDate ? { start_date: startDate } : {}\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error triggering data ingest:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Start the Mixpanel data processing pipeline\n   * @param {Object} options - Processing options\n   * @param {string} options.start_date - Start date (YYYY-MM-DD)\n   * @param {boolean} options.wipe_folder - Whether to wipe the folder before processing\n   * @returns {Promise<Object>} - Response with success status\n   */\n  startMixpanelProcessing: async (options) => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/process/start', options);\n      return response.data;\n    } catch (error) {\n      console.error('Error starting Mixpanel processing:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get the current status of Mixpanel data processing\n   * @returns {Promise<Object>} - Response with processing status\n   */\n  getMixpanelProcessStatus: async () => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/process/status');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching process status:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Cancel the current Mixpanel data processing job\n   * @returns {Promise<Object>} - Response with success status\n   */\n  cancelMixpanelProcessing: async () => {\n    try {\n      const response = await apiClient.post('/api/mixpanel/process/cancel');\n      return response.data;\n    } catch (error) {\n      console.error('Error canceling processing:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get test DB user data\n   * @param {string} distinctId - Optional user distinct ID\n   * @returns {Promise<Object>} - Response with user data\n   */\n  getTestDbUser: async (distinctId) => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/test-db-user', {\n        params: distinctId ? { distinct_id: distinctId } : {}\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching test DB user:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get test DB events data\n   * @param {string} distinctId - Optional user distinct ID\n   * @returns {Promise<Object>} - Response with events data\n   */\n  getTestDbEvents: async (distinctId) => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/test-db-events', {\n        params: distinctId ? { distinct_id: distinctId } : {}\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching test DB events:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Fetch Meta API data\n   * @param {Object} params - Request parameters\n   * @param {string} params.start_date - Start date (YYYY-MM-DD)\n   * @param {string} params.end_date - End date (YYYY-MM-DD)\n   * @param {number} params.time_increment - Time increment in days\n   * @param {string} [params.fields] - Comma-separated list of fields to retrieve\n   * @returns {Promise<Object>} - Response with Meta API data\n   */\n  fetchMetaData: async (params) => {\n    try {\n      const response = await apiClient.post('/api/meta/fetch', params);\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching Meta API data:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Check the status of an async Meta API job\n   * @param {string} reportRunId - The report run ID\n   * @returns {Promise<Object>} - Job status information\n   */\n  checkMetaJobStatus: async (reportRunId) => {\n    try {\n      const response = await apiClient.get(`/api/meta/job/${reportRunId}/status`);\n      return response.data;\n    } catch (error) {\n      console.error('Error checking Meta job status:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get results from a completed async Meta API job\n   * @param {string} reportRunId - The report run ID\n   * @param {boolean} useFileUrl - Whether to use file URL download\n   * @returns {Promise<Object>} - Job results\n   */\n  getMetaJobResults: async (reportRunId, useFileUrl = false) => {\n    try {\n      const response = await apiClient.get(`/api/meta/job/${reportRunId}/results`, {\n        params: { use_file_url: useFileUrl }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting Meta job results:', error);\n      throw error;\n    }\n  },\n\n  // --- Cohort Analyzer API Methods ---\n  analyzeCohortData: async (filters) => {\n    try {\n      const response = await apiClient.post('/api/cohort-analysis', filters);\n      return response.data;\n    } catch (error) {\n      console.error('Error analyzing cohort data:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  // --- Cohort Analyzer V3 API Methods ---\n  analyzeCohortDataV3: async (filters) => {\n    try {\n      console.log('[V3] Sending cohort analysis request to V3 API:', filters);\n      const response = await apiClient.post('/api/v3/cohort/analyze', filters);\n      console.log('[V3] Received response from V3 API:', response.data);\n      return response.data;\n    } catch (error) {\n      console.error('Error analyzing cohort data with V3 API:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  analyzeCohortDataV3Enhanced: async (filters) => {\n    try {\n      console.log('[V3] Sending enhanced cohort analysis request to V3 API:', filters);\n      const response = await apiClient.post('/api/v3/cohort/analyze-enhanced', filters);\n      console.log('[V3] Received enhanced response from V3 API:', response.data);\n      return response.data;\n    } catch (error) {\n      console.error('Error analyzing cohort data with V3 Enhanced API:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  // --- Cohort Analyzer V3 Refactored API Methods ---\n  analyzeCohortDataV3Refactored: async (filters) => {\n    try {\n      console.log('[V3-Refactored] Sending cohort analysis request to V3 Refactored API:', filters);\n      const response = await apiClient.post('/api/v3/cohort/analyze-refactored', filters);\n      console.log('[V3-Refactored] Received response from V3 Refactored API:', response.data);\n      return response.data;\n    } catch (error) {\n      console.error('Error analyzing cohort data with V3 Refactored API:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  getV3RefactoredHealth: async () => {\n    try {\n      const response = await apiClient.get('/api/v3/cohort/refactored-health');\n      return response.data;\n    } catch (error) {\n      console.error('Error checking V3 Refactored health:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  getV3RefactoredVersion: async () => {\n    try {\n      const response = await apiClient.get('/api/v3/cohort/refactored-version');\n      return response.data;\n    } catch (error) {\n      console.error('Error getting V3 Refactored version:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  // V3 Refactored Debug Methods\n  runV3RefactoredStageAnalysis: async (filters, stage) => {\n    try {\n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] CALLING runV3RefactoredStageAnalysis for stage: ${stage}`);\n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] Will POST to: /api/v3/cohort/analyze-refactored`);\n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] Filters:`, filters);\n      \n      const debugFilters = {\n        ...filters,\n        debug_mode: true,\n        debug_stage: stage,\n        pipeline_version: '3.0.0_refactored'\n      };\n      \n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] Final payload:`, debugFilters);\n      \n      const response = await apiClient.post('/api/v3/cohort/analyze-refactored', debugFilters);\n      \n      console.log(`ðŸš€ðŸš€ðŸš€ [V3-REFACTORED API] SUCCESS! Received response:`, response.data);\n      return response.data;\n    } catch (error) {\n      console.error(`ðŸš¨ðŸš¨ðŸš¨ [V3-REFACTORED API] ERROR in stage ${stage} analysis:`, error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  getV3Health: async () => {\n    try {\n      const response = await apiClient.get('/api/v3/cohort/health');\n      return response.data;\n    } catch (error) {\n      console.error('Error checking V3 health:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  getV3Version: async () => {\n    try {\n      const response = await apiClient.get('/api/v3/cohort/version');\n      return response.data;\n    } catch (error) {\n      console.error('Error getting V3 version:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  getCohortUserTimeline: async (filters) => {\n    try {\n      console.log('[DEBUG] getCohortUserTimeline called with filters:', filters);\n      // Convert optional_filters to legacy format for the unified pipeline\n      const optional_filters = filters.optional_filters || [];\n      let primary_user_filter = {};\n      let secondary_filters = [];\n      \n      if (optional_filters.length > 0) {\n        // Convert optional_filters to legacy format\n        const user_filters = optional_filters.filter(f => f.property_source === 'user');\n        const event_filters = optional_filters.filter(f => f.property_source === 'event');\n        \n        // Use the first user filter as primary_user_filter\n        primary_user_filter = user_filters.length > 0 ? user_filters[0] : {};\n        \n        // Only event filters go to secondary_filters\n        secondary_filters = event_filters;\n      } else {\n        // Fall back to legacy format if provided\n        primary_user_filter = filters.primary_user_filter || {};\n        secondary_filters = filters.secondary_filters || [];\n      }\n      \n      const payload = {\n        date_from: filters.date_from_str,\n        date_to: filters.date_to_str,\n        primary_user_filter: primary_user_filter,\n        secondary_filters: secondary_filters,\n        config: {}\n      };\n      \n      console.log('[DEBUG] getCohortUserTimeline sending payload:', payload);\n      const response = await apiClient.post('/api/cohort-pipeline/timeline', payload);\n      console.log('[DEBUG] getCohortUserTimeline received response:', response.data);\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching cohort user timeline:', error.response?.data || error.message);\n      console.error('[DEBUG] getCohortUserTimeline full error:', error);\n      throw error.response?.data || error;\n    }\n  },\n\n  getUserEventRevenueTimeline: async (filters, distinctId = null, productId = null) => {\n    try {\n      console.log('[DEBUG] getUserEventRevenueTimeline called with filters:', filters, 'distinctId:', distinctId, 'productId:', productId);\n      \n      // CRITICAL FIX: Use V3 API instead of legacy API\n      // The legacy API has the business logic bug where trial conversions incorrectly set initial_purchase = 1\n      // The V3 API uses the correct EventStateTracker that properly handles business rules\n      \n      // Convert filters to V3 format\n      const v3Payload = {\n        date_from_str: filters.date_from_str,\n        date_to_str: filters.date_to_str,\n        // Convert optional_filters to V3 user_filters format\n        user_filters: []\n      };\n      \n      // Handle filter conversion\n      if (filters.optional_filters && filters.optional_filters.length > 0) {\n        // Use optional_filters (new format)\n        v3Payload.user_filters = filters.optional_filters.filter(f => f.property_source === 'user');\n      } else if (filters.primary_user_filter && filters.primary_user_filter.property_name) {\n        // Convert legacy primary_user_filter format\n        v3Payload.user_filters = [{\n          property_name: filters.primary_user_filter.property_name,\n          property_values: filters.primary_user_filter.property_values,\n          property_source: 'user'\n        }];\n      }\n      \n      // Add user/product filtering if specified\n      if (distinctId) v3Payload.distinct_id = distinctId;\n      if (productId) v3Payload.product_id = productId;\n      \n      console.log('[DEBUG] getUserEventRevenueTimeline sending V3 payload:', v3Payload);\n      \n      // Use V3 API endpoint that has correct business logic\n      const response = await apiClient.post('/api/v3/cohort/analyze-refactored', v3Payload);\n      console.log('[DEBUG] getUserEventRevenueTimeline received V3 response:', response.data);\n      \n      // Convert V3 response to legacy format for compatibility with existing frontend code\n      const v3Data = response.data;\n      const stage3Data = v3Data?.stage_results?.stage3;\n      \n      if (!stage3Data || !stage3Data.timeline_results) {\n        throw new Error('Invalid V3 response format');\n      }\n      \n      const timelineResults = stage3Data.timeline_results;\n      \n      // Convert V3 timeline data to legacy format\n      const legacyFormat = {\n        dates: timelineResults.dates || [],\n        event_rows: {},\n        estimate_rows: {},\n        arpc_per_product: timelineResults.arpc_per_product || {},\n        available_users: Object.keys(timelineResults.user_daily_metrics || {}),\n        available_products: timelineResults.available_products || []\n      };\n      \n      // Convert daily metrics to legacy event_rows format\n      if (timelineResults.timeline_data) {\n        legacyFormat.dates.forEach(date => {\n          const dayData = timelineResults.timeline_data[date] || {};\n          \n          // Map V3 field names to legacy field names\n          if (!legacyFormat.event_rows.trial_started) legacyFormat.event_rows.trial_started = {};\n          if (!legacyFormat.event_rows.trial_pending) legacyFormat.event_rows.trial_pending = {};\n          if (!legacyFormat.event_rows.trial_ended) legacyFormat.event_rows.trial_ended = {};\n          if (!legacyFormat.event_rows.trial_converted) legacyFormat.event_rows.trial_converted = {};\n          if (!legacyFormat.event_rows.trial_canceled) legacyFormat.event_rows.trial_canceled = {};\n          if (!legacyFormat.event_rows.initial_purchase) legacyFormat.event_rows.initial_purchase = {};\n          if (!legacyFormat.event_rows.subscription_active) legacyFormat.event_rows.subscription_active = {};\n          if (!legacyFormat.event_rows.subscription_cancelled) legacyFormat.event_rows.subscription_cancelled = {};\n          if (!legacyFormat.event_rows.refund) legacyFormat.event_rows.refund = {};\n          \n          legacyFormat.event_rows.trial_started[date] = dayData.trial_started || 0;\n          legacyFormat.event_rows.trial_pending[date] = dayData.trial_pending || 0;\n          legacyFormat.event_rows.trial_ended[date] = dayData.trial_ended || 0;\n          legacyFormat.event_rows.trial_converted[date] = dayData.trial_converted || 0;\n          legacyFormat.event_rows.trial_canceled[date] = dayData.trial_cancelled || 0; // Note: cancelled vs canceled\n          legacyFormat.event_rows.initial_purchase[date] = dayData.initial_purchase || 0; // CRITICAL: This will now be 0 for trial conversions\n          legacyFormat.event_rows.subscription_active[date] = dayData.subscription_active || 0;\n          legacyFormat.event_rows.subscription_cancelled[date] = dayData.subscription_cancelled || 0;\n          legacyFormat.event_rows.refund[date] = dayData.refund_count || 0;\n          \n          // Revenue data\n          if (!legacyFormat.estimate_rows.current_revenue) legacyFormat.estimate_rows.current_revenue = {};\n          if (!legacyFormat.estimate_rows.estimated_revenue) legacyFormat.estimate_rows.estimated_revenue = {};\n          if (!legacyFormat.estimate_rows.estimated_net_revenue) legacyFormat.estimate_rows.estimated_net_revenue = {};\n          \n          legacyFormat.estimate_rows.current_revenue[date] = dayData.revenue || 0;\n          legacyFormat.estimate_rows.estimated_revenue[date] = dayData.estimated_revenue || 0;\n          legacyFormat.estimate_rows.estimated_net_revenue[date] = dayData.estimated_revenue || 0;\n        });\n      }\n      \n      // Add cumulative data for legacy compatibility\n      legacyFormat.event_rows.cumulative_initial_purchase = {};\n      let cumulativeInitialPurchase = 0;\n      legacyFormat.dates.forEach(date => {\n        cumulativeInitialPurchase += legacyFormat.event_rows.initial_purchase[date] || 0;\n        legacyFormat.event_rows.cumulative_initial_purchase[date] = cumulativeInitialPurchase;\n      });\n      \n      console.log('[DEBUG] getUserEventRevenueTimeline converted to legacy format:', legacyFormat);\n      return legacyFormat;\n      \n    } catch (err) {\n      console.error('getUserEventRevenueTimeline error:', err);\n      throw err;\n    }\n  },\n\n  getDiscoverableCohortProperties: async () => {\n    try {\n      const response = await apiClient.get('/api/cohort_analyzer/discoverable_properties');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching discoverable cohort properties:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  getDiscoverableCohortPropertyValues: async (propertyKey, propertySource) => {\n    try {\n      const response = await apiClient.get('/api/cohort_analyzer/property_values', {\n        params: { property_key: propertyKey, property_source: propertySource }\n      });\n      return response.data;\n    } catch (error) {\n      console.error(`Error fetching values for ${propertyKey} (${propertySource}):`, error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  triggerCohortPropertyDiscovery: async () => {\n    try {\n      const response = await apiClient.post('/api/cohort_analyzer/trigger_discovery');\n      return response.data;\n    } catch (error) {\n      console.error('Error triggering cohort property discovery:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n  \n  enableCohortProperties: async () => {\n    try {\n      const response = await apiClient.post('/api/cohort_analyzer/enable_properties');\n      return response.data;\n    } catch (error) {\n      console.error('Error enabling cohort properties:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n  \n  getPropertyDiscoveryStatus: async () => {\n    try {\n      const response = await apiClient.get('/api/cohort_analyzer/discovery_status');\n      return response.data;\n    } catch (error) {\n      console.error('Error checking property discovery status:', error.response?.data || error.message);\n      throw error.response?.data || error;\n    }\n  },\n\n  // --- Mixpanel Debug API Methods ---\n  getMixpanelDatabaseStats: async () => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/database-stats');\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching Mixpanel database statistics:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get events for a specific user\n   * @param {string} userId - User ID or distinct ID\n   * @returns {Promise<Array>} - Response with user events\n   */\n  getUserEvents: async (userId) => {\n    try {\n      const response = await apiClient.get('/api/mixpanel/debug/user-events', {\n        params: { user_id: userId }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error fetching user events:', error);\n      throw error;\n    }\n  },\n\n  // --- Meta Historical Data API Methods ---\n  \n  /**\n   * Start a historical data collection job\n   * @param {Object} params - Collection parameters\n   * @param {string} params.start_date - Start date (YYYY-MM-DD)\n   * @param {string} params.end_date - End date (YYYY-MM-DD)\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @returns {Promise<Object>} - Response with job ID\n   */\n  startHistoricalCollection: async (params) => {\n    try {\n      const response = await apiClient.post('/api/meta/historical/start', params);\n      return response.data;\n    } catch (error) {\n      console.error('Error starting historical collection:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get status of a historical collection job\n   * @param {string} jobId - Job ID\n   * @returns {Promise<Object>} - Job status information\n   */\n  getHistoricalJobStatus: async (jobId) => {\n    try {\n      const response = await apiClient.get(`/api/meta/historical/jobs/${jobId}/status`);\n      return response.data;\n    } catch (error) {\n      console.error('Error getting job status:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Cancel a historical collection job\n   * @param {string} jobId - Job ID\n   * @returns {Promise<Object>} - Cancellation confirmation\n   */\n  cancelHistoricalJob: async (jobId) => {\n    try {\n      const response = await apiClient.post(`/api/meta/historical/jobs/${jobId}/cancel`);\n      return response.data;\n    } catch (error) {\n      console.error('Error cancelling job:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get data coverage summary for a configuration\n   * @param {Object} params - Configuration parameters\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @param {string} [params.start_date] - Optional start date filter\n   * @param {string} [params.end_date] - Optional end date filter\n   * @returns {Promise<Object>} - Coverage summary\n   */\n  getDataCoverage: async (params) => {\n    try {\n      const response = await apiClient.get('/api/meta/historical/coverage', { params });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting data coverage:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get list of missing dates for a configuration\n   * @param {Object} params - Configuration parameters\n   * @param {string} params.start_date - Start date (YYYY-MM-DD)\n   * @param {string} params.end_date - End date (YYYY-MM-DD)\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @returns {Promise<Object>} - Missing dates information\n   */\n  getMissingDates: async (params) => {\n    try {\n      const response = await apiClient.get('/api/meta/historical/missing-dates', { params });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting missing dates:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Delete all data for a specific historical configuration\n   * @param {string} configHash - Configuration hash to delete\n   * @returns {Promise<Object>} - Deletion confirmation\n   */\n  deleteHistoricalConfiguration: async (configHash) => {\n    try {\n      const response = await apiClient.delete(`/api/meta/historical/configurations/${configHash}`);\n      return response.data;\n    } catch (error) {\n      console.error('Error deleting historical configuration:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get all stored request configurations\n   * @returns {Promise<Array>} - List of configurations\n   */\n  getHistoricalConfigurations: async () => {\n    try {\n      const response = await apiClient.get('/api/meta/historical/configurations');\n      return response.data;\n    } catch (error) {\n      console.error('Error getting configurations:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Export stored data for a configuration and date range\n   * @param {Object} params - Export parameters\n   * @param {string} params.start_date - Start date (YYYY-MM-DD)\n   * @param {string} params.end_date - End date (YYYY-MM-DD)\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @param {string} [params.format] - Export format (default: 'json')\n   * @returns {Promise<Object>} - Exported data\n   */\n  exportHistoricalData: async (params) => {\n    try {\n      const response = await apiClient.get('/api/meta/historical/export', { params });\n      return response.data;\n    } catch (error) {\n      console.error('Error exporting data:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get stored data for a specific day and configuration\n   * @param {Object} params - Day data parameters\n   * @param {string} params.date - Date (YYYY-MM-DD)\n   * @param {string} params.fields - Comma-separated list of fields\n   * @param {string} [params.breakdowns] - Comma-separated list of breakdowns\n   * @param {Object} [params.filtering] - Filtering configuration\n   * @returns {Promise<Object>} - Day data\n   */\n  getHistoricalDayData: async (params) => {\n    try {\n      const response = await apiClient.post('/api/meta/historical/get-day-data', params);\n      return response.data;\n    } catch (error) {\n      console.error('Error getting day data:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get current action mappings\n   * @returns {Promise<Object>} - Action mappings\n   */\n  getActionMappings: async () => {\n    try {\n      const response = await apiClient.get('/api/meta/action-mappings');\n      return response.data;\n    } catch (error) {\n      console.error('Error getting action mappings:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Save action mappings\n   * @param {Object} mappings - Action mappings to save\n   * @returns {Promise<Object>} - Save confirmation\n   */\n  saveActionMappings: async (mappings) => {\n    try {\n      const response = await apiClient.post('/api/meta/action-mappings', { mappings });\n      return response.data;\n    } catch (error) {\n      console.error('Error saving action mappings:', error);\n      throw error;\n    }\n  },\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}