{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect } from 'react';\nimport { loadSavedState, getDateRangeFromTimeframe } from '../components/conversion_probability/utils/conversionUtils';\nexport const useConversionProbability = () => {\n  _s();\n  // Initialize state with saved values\n  const savedState = loadSavedState();\n\n  // Analysis configuration state\n  const [config, setConfig] = useState({\n    ...savedState.config,\n    min_price_samples: savedState.config.min_price_samples || 100\n  });\n\n  // Analysis state\n  const [currentAnalysis, setCurrentAnalysis] = useState(null);\n  const [analysisProgress, setAnalysisProgress] = useState(null);\n  const [analysisResults, setAnalysisResults] = useState(null);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n\n  // NEW: New hierarchical analysis state\n  const [isRunningNewAnalysis, setIsRunningNewAnalysis] = useState(false);\n\n  // Property analysis state\n  const [propertyAnalysis, setPropertyAnalysis] = useState(null);\n  const [isAnalyzingProperties, setIsAnalyzingProperties] = useState(false);\n\n  // UI state\n  const [error, setError] = useState(null);\n  const [success, setSuccess] = useState(null);\n  const [expandedSections, setExpandedSections] = useState({\n    ...savedState.expandedSections,\n    analysisHierarchy: true // Default to expanded when analysis is complete\n  });\n\n  // Available analyses\n  const [availableAnalyses, setAvailableAnalyses] = useState([]);\n\n  // Save state to localStorage whenever it changes\n  useEffect(() => {\n    localStorage.setItem('conversionProbability_config', JSON.stringify(config));\n  }, [config]);\n  useEffect(() => {\n    localStorage.setItem('conversionProbability_expandedSections', JSON.stringify(expandedSections));\n  }, [expandedSections]);\n\n  // Load analysis results function\n  const loadAnalysisResults = async analysisId => {\n    try {\n      const response = await fetch(`/api/conversion-probability/results/${analysisId}`);\n      const data = await response.json();\n      if (data.success) {\n        setAnalysisResults(data.data);\n        // Auto-expand hierarchy section when results are loaded\n        setExpandedSections(prev => ({\n          ...prev,\n          analysisHierarchy: true\n        }));\n        loadAvailableAnalyses();\n      } else {\n        setError(data.error || 'Failed to load analysis results');\n      }\n    } catch (err) {\n      setError('Error loading analysis results: ' + err.message);\n    }\n  };\n  const loadAvailableAnalyses = async () => {\n    try {\n      const response = await fetch('/api/conversion-probability/analyses');\n      const data = await response.json();\n      if (data.success) {\n        setAvailableAnalyses(data.data.files);\n      }\n    } catch (err) {\n      console.error('Error loading available analyses:', err);\n    }\n  };\n\n  // Polling for progress updates\n  useEffect(() => {\n    let interval;\n    if (currentAnalysis && isAnalyzing) {\n      interval = setInterval(async () => {\n        try {\n          const response = await fetch(`/api/conversion-probability/progress/${currentAnalysis}`);\n          const data = await response.json();\n          if (data.success) {\n            setAnalysisProgress(data.data.progress);\n            if (data.data.status === 'completed' || data.data.status === 'failed') {\n              setIsAnalyzing(false);\n              if (data.data.status === 'completed') {\n                setSuccess('Analysis completed successfully!');\n                loadAnalysisResults(currentAnalysis);\n              } else {\n                setError('Analysis failed. Please try again.');\n              }\n            }\n          }\n        } catch (err) {\n          console.error('Error polling progress:', err);\n        }\n      }, 2000);\n    }\n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [currentAnalysis, isAnalyzing]);\n\n  // Load available analyses on component mount\n  useEffect(() => {\n    loadAvailableAnalyses();\n  }, []);\n  const analyzeProperties = async () => {\n    setIsAnalyzingProperties(true);\n    setError(null);\n    try {\n      const dateRange = getDateRangeFromTimeframe(config.timeframe);\n      const response = await fetch('/api/conversion-probability/analyze-properties', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          timeframe_start: dateRange.start,\n          timeframe_end: dateRange.end,\n          sample_limit: 10000,\n          min_price_samples: config.min_price_samples,\n          min_cohort_size: config.min_cohort_size\n        })\n      });\n      const data = await response.json();\n      if (data.success) {\n        setPropertyAnalysis(data.data);\n        setSuccess('Property analysis completed successfully!');\n        setExpandedSections(prev => ({\n          ...prev,\n          propertyAnalysis: false\n        }));\n      } else {\n        setError(data.error || 'Property analysis failed');\n      }\n    } catch (err) {\n      setError('Error analyzing properties: ' + err.message);\n    } finally {\n      setIsAnalyzingProperties(false);\n    }\n  };\n  const startAnalysis = async () => {\n    setIsAnalyzing(true);\n    setError(null);\n    setAnalysisProgress(null);\n    try {\n      const dateRange = getDateRangeFromTimeframe(config.timeframe);\n      const requestBody = {\n        timeframe_start: dateRange.start,\n        timeframe_end: dateRange.end,\n        min_cohort_size: config.min_cohort_size,\n        force_recalculate: config.force_recalculate\n      };\n      if (propertyAnalysis) {\n        requestBody.existing_property_analysis = propertyAnalysis;\n      }\n      const response = await fetch('/api/conversion-probability/start-analysis', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      });\n      const data = await response.json();\n      if (data.success) {\n        setCurrentAnalysis(data.data.analysis_id);\n        if (data.data.cached) {\n          setIsAnalyzing(false);\n          setSuccess('Using cached analysis results!');\n          loadAnalysisResults(data.data.analysis_id);\n        } else {\n          setSuccess(`Analysis started! Estimated duration: ${data.data.estimated_duration_minutes} minutes`);\n        }\n      } else {\n        setError(data.error || 'Failed to start analysis');\n        setIsAnalyzing(false);\n      }\n    } catch (err) {\n      setError('Error starting analysis: ' + err.message);\n      setIsAnalyzing(false);\n    }\n  };\n\n  // NEW: Run new hierarchical analysis\n  const runNewHierarchicalAnalysis = async () => {\n    setIsRunningNewAnalysis(true);\n    setError(null);\n    setAnalysisResults(null); // Clear previous results\n\n    try {\n      // NEW: Don't send any timeframe - let the backend use the default comprehensive range (2024-01-01 to today)\n      const requestBody = {}; // Empty - will use 2024-01-01 to today automatically\n\n      const response = await fetch('/api/conversion-probability/run-new-hierarchical-analysis', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(requestBody)\n      });\n      const data = await response.json();\n      if (data.success) {\n        // Results are returned immediately since the new pipeline runs synchronously\n        setSuccess(`âœ¨ New hierarchical analysis completed! ${data.data.timeframe_description} - Processed ${data.data.total_combinations} segments with ${data.data.rollup_percentage.toFixed(1)}% rollup rate.`);\n\n        // Load the results from the file (they were saved to latest_analysis.json)\n        // We can either use the analysis_id or just load the latest results\n        await loadLatestAnalysisResults();\n\n        // Auto-expand hierarchy section\n        setExpandedSections(prev => ({\n          ...prev,\n          analysisHierarchy: true\n        }));\n      } else {\n        setError(data.error || 'New hierarchical analysis failed');\n      }\n    } catch (err) {\n      setError('Error running new hierarchical analysis: ' + err.message);\n    } finally {\n      setIsRunningNewAnalysis(false);\n    }\n  };\n\n  // Helper function to load latest analysis results (for new pipeline)\n  const loadLatestAnalysisResults = async () => {\n    try {\n      // Since the new pipeline saves to latest_analysis.json, we can try to load it directly\n      // or use a generic endpoint that loads the latest\n      const response = await fetch(`/api/conversion-probability/results/latest`);\n      let data = await response.json();\n      if (!data.success) {\n        // Fallback: get available analyses and load the most recent one\n        const analysesResponse = await fetch('/api/conversion-probability/analyses');\n        const analysesData = await analysesResponse.json();\n        if (analysesData.success && analysesData.data.files.length > 0) {\n          // Get the most recent analysis\n          const mostRecentAnalysis = analysesData.data.files[0]; // Assumes they're sorted by date\n          data = await (await fetch(`/api/conversion-probability/results/${mostRecentAnalysis.analysis_id}`)).json();\n        }\n      }\n      if (data.success) {\n        setAnalysisResults(data.data);\n        loadAvailableAnalyses();\n      }\n    } catch (err) {\n      console.error('Error loading latest analysis results:', err);\n      // Try alternative approach - reload the page to pick up the new file\n      setTimeout(() => {\n        window.location.reload();\n      }, 1000);\n    }\n  };\n  const toggleSection = section => {\n    setExpandedSections(prev => ({\n      ...prev,\n      [section]: !prev[section]\n    }));\n  };\n  return {\n    // State\n    config,\n    currentAnalysis,\n    analysisProgress,\n    analysisResults,\n    isAnalyzing,\n    isRunningNewAnalysis,\n    // NEW\n    propertyAnalysis,\n    isAnalyzingProperties,\n    error,\n    success,\n    expandedSections,\n    availableAnalyses,\n    // Actions\n    setConfig,\n    setError,\n    setSuccess,\n    analyzeProperties,\n    startAnalysis,\n    runNewHierarchicalAnalysis,\n    // NEW\n    toggleSection\n  };\n};\n_s(useConversionProbability, \"79uPLAS7Y+yev2R5CY051tPyXNI=\");","map":{"version":3,"names":["useState","useEffect","loadSavedState","getDateRangeFromTimeframe","useConversionProbability","_s","savedState","config","setConfig","min_price_samples","currentAnalysis","setCurrentAnalysis","analysisProgress","setAnalysisProgress","analysisResults","setAnalysisResults","isAnalyzing","setIsAnalyzing","isRunningNewAnalysis","setIsRunningNewAnalysis","propertyAnalysis","setPropertyAnalysis","isAnalyzingProperties","setIsAnalyzingProperties","error","setError","success","setSuccess","expandedSections","setExpandedSections","analysisHierarchy","availableAnalyses","setAvailableAnalyses","localStorage","setItem","JSON","stringify","loadAnalysisResults","analysisId","response","fetch","data","json","prev","loadAvailableAnalyses","err","message","files","console","interval","setInterval","progress","status","clearInterval","analyzeProperties","dateRange","timeframe","method","headers","body","timeframe_start","start","timeframe_end","end","sample_limit","min_cohort_size","startAnalysis","requestBody","force_recalculate","existing_property_analysis","analysis_id","cached","estimated_duration_minutes","runNewHierarchicalAnalysis","timeframe_description","total_combinations","rollup_percentage","toFixed","loadLatestAnalysisResults","analysesResponse","analysesData","length","mostRecentAnalysis","setTimeout","window","location","reload","toggleSection","section"],"sources":["/Users/joshuakaufman/untitled folder 3/orchestrator/dashboard/client/src/hooks/useConversionProbability.js"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { loadSavedState, getDateRangeFromTimeframe } from '../components/conversion_probability/utils/conversionUtils';\n\nexport const useConversionProbability = () => {\n  // Initialize state with saved values\n  const savedState = loadSavedState();\n  \n  // Analysis configuration state\n  const [config, setConfig] = useState({\n    ...savedState.config,\n    min_price_samples: savedState.config.min_price_samples || 100\n  });\n\n  // Analysis state\n  const [currentAnalysis, setCurrentAnalysis] = useState(null);\n  const [analysisProgress, setAnalysisProgress] = useState(null);\n  const [analysisResults, setAnalysisResults] = useState(null);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n\n  // NEW: New hierarchical analysis state\n  const [isRunningNewAnalysis, setIsRunningNewAnalysis] = useState(false);\n\n  // Property analysis state\n  const [propertyAnalysis, setPropertyAnalysis] = useState(null);\n  const [isAnalyzingProperties, setIsAnalyzingProperties] = useState(false);\n\n  // UI state\n  const [error, setError] = useState(null);\n  const [success, setSuccess] = useState(null);\n  const [expandedSections, setExpandedSections] = useState({\n    ...savedState.expandedSections,\n    analysisHierarchy: true // Default to expanded when analysis is complete\n  });\n\n  // Available analyses\n  const [availableAnalyses, setAvailableAnalyses] = useState([]);\n\n  // Save state to localStorage whenever it changes\n  useEffect(() => {\n    localStorage.setItem('conversionProbability_config', JSON.stringify(config));\n  }, [config]);\n\n  useEffect(() => {\n    localStorage.setItem('conversionProbability_expandedSections', JSON.stringify(expandedSections));\n  }, [expandedSections]);\n\n  // Load analysis results function\n  const loadAnalysisResults = async (analysisId) => {\n    try {\n      const response = await fetch(`/api/conversion-probability/results/${analysisId}`);\n      const data = await response.json();\n      \n      if (data.success) {\n        setAnalysisResults(data.data);\n        // Auto-expand hierarchy section when results are loaded\n        setExpandedSections(prev => ({ ...prev, analysisHierarchy: true }));\n        loadAvailableAnalyses();\n      } else {\n        setError(data.error || 'Failed to load analysis results');\n      }\n    } catch (err) {\n      setError('Error loading analysis results: ' + err.message);\n    }\n  };\n\n  const loadAvailableAnalyses = async () => {\n    try {\n      const response = await fetch('/api/conversion-probability/analyses');\n      const data = await response.json();\n      \n      if (data.success) {\n        setAvailableAnalyses(data.data.files);\n      }\n    } catch (err) {\n      console.error('Error loading available analyses:', err);\n    }\n  };\n\n  // Polling for progress updates\n  useEffect(() => {\n    let interval;\n    if (currentAnalysis && isAnalyzing) {\n      interval = setInterval(async () => {\n        try {\n          const response = await fetch(`/api/conversion-probability/progress/${currentAnalysis}`);\n          const data = await response.json();\n          \n          if (data.success) {\n            setAnalysisProgress(data.data.progress);\n            \n            if (data.data.status === 'completed' || data.data.status === 'failed') {\n              setIsAnalyzing(false);\n              if (data.data.status === 'completed') {\n                setSuccess('Analysis completed successfully!');\n                loadAnalysisResults(currentAnalysis);\n              } else {\n                setError('Analysis failed. Please try again.');\n              }\n            }\n          }\n        } catch (err) {\n          console.error('Error polling progress:', err);\n        }\n      }, 2000);\n    }\n\n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [currentAnalysis, isAnalyzing]);\n\n  // Load available analyses on component mount\n  useEffect(() => {\n    loadAvailableAnalyses();\n  }, []);\n\n  const analyzeProperties = async () => {\n    setIsAnalyzingProperties(true);\n    setError(null);\n    \n    try {\n      const dateRange = getDateRangeFromTimeframe(config.timeframe);\n      \n      const response = await fetch('/api/conversion-probability/analyze-properties', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          timeframe_start: dateRange.start,\n          timeframe_end: dateRange.end,\n          sample_limit: 10000,\n          min_price_samples: config.min_price_samples,\n          min_cohort_size: config.min_cohort_size\n        }),\n      });\n\n      const data = await response.json();\n      \n      if (data.success) {\n        setPropertyAnalysis(data.data);\n        setSuccess('Property analysis completed successfully!');\n        setExpandedSections(prev => ({ ...prev, propertyAnalysis: false }));\n      } else {\n        setError(data.error || 'Property analysis failed');\n      }\n    } catch (err) {\n      setError('Error analyzing properties: ' + err.message);\n    } finally {\n      setIsAnalyzingProperties(false);\n    }\n  };\n\n  const startAnalysis = async () => {\n    setIsAnalyzing(true);\n    setError(null);\n    setAnalysisProgress(null);\n    \n    try {\n      const dateRange = getDateRangeFromTimeframe(config.timeframe);\n      \n      const requestBody = {\n        timeframe_start: dateRange.start,\n        timeframe_end: dateRange.end,\n        min_cohort_size: config.min_cohort_size,\n        force_recalculate: config.force_recalculate\n      };\n      \n      if (propertyAnalysis) {\n        requestBody.existing_property_analysis = propertyAnalysis;\n      }\n      \n      const response = await fetch('/api/conversion-probability/start-analysis', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody),\n      });\n\n      const data = await response.json();\n      \n      if (data.success) {\n        setCurrentAnalysis(data.data.analysis_id);\n        \n        if (data.data.cached) {\n          setIsAnalyzing(false);\n          setSuccess('Using cached analysis results!');\n          loadAnalysisResults(data.data.analysis_id);\n        } else {\n          setSuccess(`Analysis started! Estimated duration: ${data.data.estimated_duration_minutes} minutes`);\n        }\n      } else {\n        setError(data.error || 'Failed to start analysis');\n        setIsAnalyzing(false);\n      }\n    } catch (err) {\n      setError('Error starting analysis: ' + err.message);\n      setIsAnalyzing(false);\n    }\n  };\n\n  // NEW: Run new hierarchical analysis\n  const runNewHierarchicalAnalysis = async () => {\n    setIsRunningNewAnalysis(true);\n    setError(null);\n    setAnalysisResults(null); // Clear previous results\n    \n    try {\n      // NEW: Don't send any timeframe - let the backend use the default comprehensive range (2024-01-01 to today)\n      const requestBody = {}; // Empty - will use 2024-01-01 to today automatically\n      \n      const response = await fetch('/api/conversion-probability/run-new-hierarchical-analysis', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody),\n      });\n\n      const data = await response.json();\n      \n      if (data.success) {\n        // Results are returned immediately since the new pipeline runs synchronously\n        setSuccess(`âœ¨ New hierarchical analysis completed! ${data.data.timeframe_description} - Processed ${data.data.total_combinations} segments with ${data.data.rollup_percentage.toFixed(1)}% rollup rate.`);\n        \n        // Load the results from the file (they were saved to latest_analysis.json)\n        // We can either use the analysis_id or just load the latest results\n        await loadLatestAnalysisResults();\n        \n        // Auto-expand hierarchy section\n        setExpandedSections(prev => ({ ...prev, analysisHierarchy: true }));\n        \n      } else {\n        setError(data.error || 'New hierarchical analysis failed');\n      }\n    } catch (err) {\n      setError('Error running new hierarchical analysis: ' + err.message);\n    } finally {\n      setIsRunningNewAnalysis(false);\n    }\n  };\n\n  // Helper function to load latest analysis results (for new pipeline)\n  const loadLatestAnalysisResults = async () => {\n    try {\n      // Since the new pipeline saves to latest_analysis.json, we can try to load it directly\n      // or use a generic endpoint that loads the latest\n      const response = await fetch(`/api/conversion-probability/results/latest`);\n      let data = await response.json();\n      \n      if (!data.success) {\n        // Fallback: get available analyses and load the most recent one\n        const analysesResponse = await fetch('/api/conversion-probability/analyses');\n        const analysesData = await analysesResponse.json();\n        \n        if (analysesData.success && analysesData.data.files.length > 0) {\n          // Get the most recent analysis\n          const mostRecentAnalysis = analysesData.data.files[0]; // Assumes they're sorted by date\n          data = await (await fetch(`/api/conversion-probability/results/${mostRecentAnalysis.analysis_id}`)).json();\n        }\n      }\n      \n      if (data.success) {\n        setAnalysisResults(data.data);\n        loadAvailableAnalyses();\n      }\n    } catch (err) {\n      console.error('Error loading latest analysis results:', err);\n      // Try alternative approach - reload the page to pick up the new file\n      setTimeout(() => {\n        window.location.reload();\n      }, 1000);\n    }\n  };\n\n  const toggleSection = (section) => {\n    setExpandedSections(prev => ({\n      ...prev,\n      [section]: !prev[section]\n    }));\n  };\n\n  return {\n    // State\n    config,\n    currentAnalysis,\n    analysisProgress,\n    analysisResults,\n    isAnalyzing,\n    isRunningNewAnalysis, // NEW\n    propertyAnalysis,\n    isAnalyzingProperties,\n    error,\n    success,\n    expandedSections,\n    availableAnalyses,\n\n    // Actions\n    setConfig,\n    setError,\n    setSuccess,\n    analyzeProperties,\n    startAnalysis,\n    runNewHierarchicalAnalysis, // NEW\n    toggleSection\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}