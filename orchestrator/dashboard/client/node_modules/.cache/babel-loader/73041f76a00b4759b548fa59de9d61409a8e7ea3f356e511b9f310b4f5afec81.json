{"ast":null,"code":"/**\n * Utility functions for applying action mappings to Meta API data\n */\n\n/**\n * Load action mappings from localStorage\n * @returns {Object} Action mappings object\n */\nexport const loadActionMappings = () => {\n  try {\n    const savedMappings = localStorage.getItem('meta_action_mappings');\n    return savedMappings ? JSON.parse(savedMappings) : {};\n  } catch (error) {\n    console.error('Error loading action mappings:', error);\n    return {};\n  }\n};\n\n/**\n * Apply action mappings to a single record\n * @param {Object} record - Meta API record\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Record with mapped business concepts\n */\nexport const applyMappingsToRecord = (record, mappings = null) => {\n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  const mappedRecord = {\n    ...record\n  };\n\n  // Apply mappings to each business concept\n  Object.entries(mappings).forEach(([conceptName, mapping]) => {\n    const {\n      actionTypes,\n      aggregationType\n    } = mapping;\n\n    // Calculate mapped values for actions (counts)\n    const actionValues = getActionValuesByTypes(record.actions, actionTypes);\n    mappedRecord[`${conceptName}_count`] = aggregateValues(actionValues, aggregationType);\n\n    // Calculate mapped values for action_values (monetary values)\n    const monetaryValues = getActionValuesByTypes(record.action_values, actionTypes);\n    mappedRecord[`${conceptName}_value`] = aggregateValues(monetaryValues, aggregationType);\n\n    // Calculate mapped values for conversions\n    const conversionCounts = getActionValuesByTypes(record.conversions, actionTypes);\n    mappedRecord[`${conceptName}_conversions`] = aggregateValues(conversionCounts, aggregationType);\n\n    // Calculate mapped values for conversion_values\n    const conversionValues = getActionValuesByTypes(record.conversion_values, actionTypes);\n    mappedRecord[`${conceptName}_conversion_value`] = aggregateValues(conversionValues, aggregationType);\n\n    // Store the breakdown for debugging\n    mappedRecord[`${conceptName}_breakdown`] = {\n      count: actionValues,\n      value: monetaryValues,\n      conversions: conversionCounts,\n      conversion_value: conversionValues\n    };\n  });\n  return mappedRecord;\n};\n\n/**\n * Get values from action array for specific action types\n * @param {Array} actions - Array of action objects\n * @param {Array} targetActionTypes - Action types to filter for\n * @returns {Array} Array of values for matching action types\n */\nconst getActionValuesByTypes = (actions, targetActionTypes) => {\n  if (!Array.isArray(actions) || !Array.isArray(targetActionTypes)) {\n    return [];\n  }\n  return actions.filter(action => targetActionTypes.includes(action.action_type)).map(action => parseFloat(action.value) || 0);\n};\n\n/**\n * Aggregate values according to the specified aggregation type\n * @param {Array} values - Array of numeric values\n * @param {string} aggregationType - 'sum', 'count', 'average'\n * @returns {number} Aggregated value\n */\nconst aggregateValues = (values, aggregationType) => {\n  if (!Array.isArray(values) || values.length === 0) {\n    return 0;\n  }\n  switch (aggregationType) {\n    case 'sum':\n      return values.reduce((sum, val) => sum + val, 0);\n    case 'count':\n      return values.length;\n    case 'average':\n      return values.reduce((sum, val) => sum + val, 0) / values.length;\n    default:\n      return values.reduce((sum, val) => sum + val, 0);\n  }\n};\n\n/**\n * Apply mappings to an array of records\n * @param {Array} records - Array of Meta API records\n * @param {Object} mappings - Action mappings configuration\n * @returns {Array} Array of records with mapped business concepts\n */\nexport const applyMappingsToRecords = (records, mappings = null) => {\n  if (!Array.isArray(records)) {\n    return records;\n  }\n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  return records.map(record => applyMappingsToRecord(record, mappings));\n};\n\n/**\n * Get summary statistics for mapped concepts across multiple records\n * @param {Array} records - Array of records with applied mappings\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Summary statistics for each concept\n */\nexport const getMappedConceptSummary = (records, mappings = null) => {\n  if (!Array.isArray(records) || records.length === 0) {\n    return {};\n  }\n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  const summary = {};\n  Object.keys(mappings).forEach(conceptName => {\n    const counts = records.map(r => r[`${conceptName}_count`] || 0);\n    const values = records.map(r => r[`${conceptName}_value`] || 0);\n    const conversions = records.map(r => r[`${conceptName}_conversions`] || 0);\n    const conversionValues = records.map(r => r[`${conceptName}_conversion_value`] || 0);\n    summary[conceptName] = {\n      total_count: counts.reduce((sum, val) => sum + val, 0),\n      total_value: values.reduce((sum, val) => sum + val, 0),\n      total_conversions: conversions.reduce((sum, val) => sum + val, 0),\n      total_conversion_value: conversionValues.reduce((sum, val) => sum + val, 0),\n      avg_count: counts.reduce((sum, val) => sum + val, 0) / counts.length,\n      avg_value: values.reduce((sum, val) => sum + val, 0) / values.length,\n      records_with_data: records.filter(r => (r[`${conceptName}_count`] || 0) > 0).length\n    };\n  });\n  return summary;\n};\n\n/**\n * Format a record for better display, including mapped concepts\n * @param {Object} record - Record with applied mappings\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Formatted record for display\n */\nexport const formatRecordForDisplay = (record, mappings = null) => {\n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  const formatted = {\n    ...record\n  };\n\n  // Add a section for mapped business concepts\n  formatted.business_metrics = {};\n  Object.keys(mappings).forEach(conceptName => {\n    formatted.business_metrics[conceptName] = {\n      count: record[`${conceptName}_count`] || 0,\n      value: record[`${conceptName}_value`] || 0,\n      conversions: record[`${conceptName}_conversions`] || 0,\n      conversion_value: record[`${conceptName}_conversion_value`] || 0\n    };\n  });\n  return formatted;\n};\n\n/**\n * Validate that action mappings are properly configured\n * @param {Object} mappings - Action mappings to validate\n * @returns {Object} Validation result with errors and warnings\n */\nexport const validateActionMappings = mappings => {\n  const errors = [];\n  const warnings = [];\n  Object.entries(mappings).forEach(([conceptName, mapping]) => {\n    if (!conceptName || conceptName.trim() === '') {\n      errors.push('Concept name cannot be empty');\n    }\n    if (!mapping.actionTypes || !Array.isArray(mapping.actionTypes) || mapping.actionTypes.length === 0) {\n      errors.push(`Concept '${conceptName}' has no action types defined`);\n    }\n    if (!['sum', 'count', 'average'].includes(mapping.aggregationType)) {\n      errors.push(`Concept '${conceptName}' has invalid aggregation type: ${mapping.aggregationType}`);\n    }\n\n    // Check for overlapping action types\n    const actionTypes = mapping.actionTypes;\n    const duplicates = actionTypes.filter((item, index) => actionTypes.indexOf(item) !== index);\n    if (duplicates.length > 0) {\n      warnings.push(`Concept '${conceptName}' has duplicate action types: ${duplicates.join(', ')}`);\n    }\n  });\n  return {\n    errors,\n    warnings,\n    isValid: errors.length === 0\n  };\n};","map":{"version":3,"names":["loadActionMappings","savedMappings","localStorage","getItem","JSON","parse","error","console","applyMappingsToRecord","record","mappings","mappedRecord","Object","entries","forEach","conceptName","mapping","actionTypes","aggregationType","actionValues","getActionValuesByTypes","actions","aggregateValues","monetaryValues","action_values","conversionCounts","conversions","conversionValues","conversion_values","count","value","conversion_value","targetActionTypes","Array","isArray","filter","action","includes","action_type","map","parseFloat","values","length","reduce","sum","val","applyMappingsToRecords","records","getMappedConceptSummary","summary","keys","counts","r","total_count","total_value","total_conversions","total_conversion_value","avg_count","avg_value","records_with_data","formatRecordForDisplay","formatted","business_metrics","validateActionMappings","errors","warnings","trim","push","duplicates","item","index","indexOf","join","isValid"],"sources":["/Users/joshuakaufman/untitled folder 3/orchestrator/dashboard/client/src/components/meta/utils/actionMappingUtils.js"],"sourcesContent":["/**\n * Utility functions for applying action mappings to Meta API data\n */\n\n/**\n * Load action mappings from localStorage\n * @returns {Object} Action mappings object\n */\nexport const loadActionMappings = () => {\n  try {\n    const savedMappings = localStorage.getItem('meta_action_mappings');\n    return savedMappings ? JSON.parse(savedMappings) : {};\n  } catch (error) {\n    console.error('Error loading action mappings:', error);\n    return {};\n  }\n};\n\n/**\n * Apply action mappings to a single record\n * @param {Object} record - Meta API record\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Record with mapped business concepts\n */\nexport const applyMappingsToRecord = (record, mappings = null) => {\n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n\n  const mappedRecord = { ...record };\n  \n  // Apply mappings to each business concept\n  Object.entries(mappings).forEach(([conceptName, mapping]) => {\n    const { actionTypes, aggregationType } = mapping;\n    \n    // Calculate mapped values for actions (counts)\n    const actionValues = getActionValuesByTypes(record.actions, actionTypes);\n    mappedRecord[`${conceptName}_count`] = aggregateValues(actionValues, aggregationType);\n    \n    // Calculate mapped values for action_values (monetary values)\n    const monetaryValues = getActionValuesByTypes(record.action_values, actionTypes);\n    mappedRecord[`${conceptName}_value`] = aggregateValues(monetaryValues, aggregationType);\n    \n    // Calculate mapped values for conversions\n    const conversionCounts = getActionValuesByTypes(record.conversions, actionTypes);\n    mappedRecord[`${conceptName}_conversions`] = aggregateValues(conversionCounts, aggregationType);\n    \n    // Calculate mapped values for conversion_values\n    const conversionValues = getActionValuesByTypes(record.conversion_values, actionTypes);\n    mappedRecord[`${conceptName}_conversion_value`] = aggregateValues(conversionValues, aggregationType);\n    \n    // Store the breakdown for debugging\n    mappedRecord[`${conceptName}_breakdown`] = {\n      count: actionValues,\n      value: monetaryValues,\n      conversions: conversionCounts,\n      conversion_value: conversionValues\n    };\n  });\n  \n  return mappedRecord;\n};\n\n/**\n * Get values from action array for specific action types\n * @param {Array} actions - Array of action objects\n * @param {Array} targetActionTypes - Action types to filter for\n * @returns {Array} Array of values for matching action types\n */\nconst getActionValuesByTypes = (actions, targetActionTypes) => {\n  if (!Array.isArray(actions) || !Array.isArray(targetActionTypes)) {\n    return [];\n  }\n  \n  return actions\n    .filter(action => targetActionTypes.includes(action.action_type))\n    .map(action => parseFloat(action.value) || 0);\n};\n\n/**\n * Aggregate values according to the specified aggregation type\n * @param {Array} values - Array of numeric values\n * @param {string} aggregationType - 'sum', 'count', 'average'\n * @returns {number} Aggregated value\n */\nconst aggregateValues = (values, aggregationType) => {\n  if (!Array.isArray(values) || values.length === 0) {\n    return 0;\n  }\n  \n  switch (aggregationType) {\n    case 'sum':\n      return values.reduce((sum, val) => sum + val, 0);\n    case 'count':\n      return values.length;\n    case 'average':\n      return values.reduce((sum, val) => sum + val, 0) / values.length;\n    default:\n      return values.reduce((sum, val) => sum + val, 0);\n  }\n};\n\n/**\n * Apply mappings to an array of records\n * @param {Array} records - Array of Meta API records\n * @param {Object} mappings - Action mappings configuration\n * @returns {Array} Array of records with mapped business concepts\n */\nexport const applyMappingsToRecords = (records, mappings = null) => {\n  if (!Array.isArray(records)) {\n    return records;\n  }\n  \n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  \n  return records.map(record => applyMappingsToRecord(record, mappings));\n};\n\n/**\n * Get summary statistics for mapped concepts across multiple records\n * @param {Array} records - Array of records with applied mappings\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Summary statistics for each concept\n */\nexport const getMappedConceptSummary = (records, mappings = null) => {\n  if (!Array.isArray(records) || records.length === 0) {\n    return {};\n  }\n  \n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  \n  const summary = {};\n  \n  Object.keys(mappings).forEach(conceptName => {\n    const counts = records.map(r => r[`${conceptName}_count`] || 0);\n    const values = records.map(r => r[`${conceptName}_value`] || 0);\n    const conversions = records.map(r => r[`${conceptName}_conversions`] || 0);\n    const conversionValues = records.map(r => r[`${conceptName}_conversion_value`] || 0);\n    \n    summary[conceptName] = {\n      total_count: counts.reduce((sum, val) => sum + val, 0),\n      total_value: values.reduce((sum, val) => sum + val, 0),\n      total_conversions: conversions.reduce((sum, val) => sum + val, 0),\n      total_conversion_value: conversionValues.reduce((sum, val) => sum + val, 0),\n      avg_count: counts.reduce((sum, val) => sum + val, 0) / counts.length,\n      avg_value: values.reduce((sum, val) => sum + val, 0) / values.length,\n      records_with_data: records.filter(r => (r[`${conceptName}_count`] || 0) > 0).length\n    };\n  });\n  \n  return summary;\n};\n\n/**\n * Format a record for better display, including mapped concepts\n * @param {Object} record - Record with applied mappings\n * @param {Object} mappings - Action mappings configuration\n * @returns {Object} Formatted record for display\n */\nexport const formatRecordForDisplay = (record, mappings = null) => {\n  if (!mappings) {\n    mappings = loadActionMappings();\n  }\n  \n  const formatted = { ...record };\n  \n  // Add a section for mapped business concepts\n  formatted.business_metrics = {};\n  \n  Object.keys(mappings).forEach(conceptName => {\n    formatted.business_metrics[conceptName] = {\n      count: record[`${conceptName}_count`] || 0,\n      value: record[`${conceptName}_value`] || 0,\n      conversions: record[`${conceptName}_conversions`] || 0,\n      conversion_value: record[`${conceptName}_conversion_value`] || 0\n    };\n  });\n  \n  return formatted;\n};\n\n/**\n * Validate that action mappings are properly configured\n * @param {Object} mappings - Action mappings to validate\n * @returns {Object} Validation result with errors and warnings\n */\nexport const validateActionMappings = (mappings) => {\n  const errors = [];\n  const warnings = [];\n  \n  Object.entries(mappings).forEach(([conceptName, mapping]) => {\n    if (!conceptName || conceptName.trim() === '') {\n      errors.push('Concept name cannot be empty');\n    }\n    \n    if (!mapping.actionTypes || !Array.isArray(mapping.actionTypes) || mapping.actionTypes.length === 0) {\n      errors.push(`Concept '${conceptName}' has no action types defined`);\n    }\n    \n    if (!['sum', 'count', 'average'].includes(mapping.aggregationType)) {\n      errors.push(`Concept '${conceptName}' has invalid aggregation type: ${mapping.aggregationType}`);\n    }\n    \n    // Check for overlapping action types\n    const actionTypes = mapping.actionTypes;\n    const duplicates = actionTypes.filter((item, index) => actionTypes.indexOf(item) !== index);\n    if (duplicates.length > 0) {\n      warnings.push(`Concept '${conceptName}' has duplicate action types: ${duplicates.join(', ')}`);\n    }\n  });\n  \n  return { errors, warnings, isValid: errors.length === 0 };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}