{"ast":null,"code":"import { ACTION_METRICS, ACTION_TYPE_ALLOWED_BREAKDOWNS, GEOGRAPHY_GROUP, DEVICE_GROUP, PLACEMENT_GROUP, TIME_GROUP, ASSET_GROUP, DELIVERY_ONLY_FIELDS, VALID_PAIRS, VIRTUAL_OS_MAP } from './metaConstants';\n\n// Helper to recognise a virtual OS ID\nexport const isVirtualOS = id => id === 'os_ios' || id === 'os_and';\n\n// Helper to remove falsy entries from an object before storing to localStorage\nexport const compactObject = obj => Object.fromEntries(Object.entries(obj).filter(([_, v]) => v));\n\n// Validate combinations of selected fields and breakdowns\nexport const validateMetaBreakdownCombo = (fields, breakdowns) => {\n  const selectedFieldIds = Object.entries(fields).filter(([_, isSelected]) => isSelected).map(([id, _]) => id);\n  const selectedBreakdownIds = Object.entries(breakdowns).filter(([_, isSelected]) => isSelected).map(([id, _]) => id).sort();\n  const hasActionMetrics = selectedFieldIds.some(field => ACTION_METRICS.includes(field));\n  const errors = [];\n  let valid = true;\n\n  // Check breakdown limit\n  if (selectedBreakdownIds.length > 2) {\n    errors.push(\"Maximum of 2 breakdowns allowed\");\n    valid = false;\n  }\n\n  // Check action metric restrictions\n  if (hasActionMetrics) {\n    if (selectedBreakdownIds.length > 1) {\n      errors.push(\"When using action metrics, you can select at most 1 breakdown because Meta adds 'action_type' as an implicit breakdown\");\n      valid = false;\n    }\n    if (selectedBreakdownIds.length === 1 && !ACTION_TYPE_ALLOWED_BREAKDOWNS.includes(selectedBreakdownIds[0])) {\n      errors.push(`'${selectedBreakdownIds[0]}' is no longer valid. Use one of: ` + ACTION_TYPE_ALLOWED_BREAKDOWNS.join(', '));\n      valid = false;\n    }\n  }\n\n  // Check group restrictions if we have multiple breakdowns\n  if (selectedBreakdownIds.length === 2) {\n    const [bd1, bd2] = selectedBreakdownIds;\n    const isDeliveryOnlyRequest = selectedFieldIds.length > 0 && selectedFieldIds.every(field => DELIVERY_ONLY_FIELDS.includes(field));\n    const isPairInValidPairs = VALID_PAIRS.some(pair => pair[0] === bd1 && pair[1] === bd2 || pair[1] === bd1 && pair[0] === bd2);\n    let pairErrorFound = false; // Flag to prevent multiple errors for the same pair\n\n    // Hourly breakdowns must always stand alone\n    if (TIME_GROUP.includes(bd1) || TIME_GROUP.includes(bd2)) {\n      errors.push(\"Hourly breakdowns must stand alone\");\n      valid = false;\n      pairErrorFound = true;\n    }\n    if (!pairErrorFound) {\n      if (isPairInValidPairs) {\n        // Pair is in VALID_PAIRS. No further same-group or general validity check needed for these.\n        // Hourly check already done.\n      } else {\n        // Pair is NOT in VALID_PAIRS. Check for same-group violations.\n        if (GEOGRAPHY_GROUP.includes(bd1) && GEOGRAPHY_GROUP.includes(bd2) || DEVICE_GROUP.includes(bd1) && DEVICE_GROUP.includes(bd2) || PLACEMENT_GROUP.includes(bd1) && PLACEMENT_GROUP.includes(bd2) ||\n        // ASSET_GROUP has a special condition with isDeliveryOnlyRequest\n        !isDeliveryOnlyRequest && ASSET_GROUP.includes(bd1) && ASSET_GROUP.includes(bd2)\n        // TIME_GROUP is implicitly handled by the hourly check above if they are in the same group\n        ) {\n          errors.push(`Cannot select multiple breakdowns from the same group (${bd1}, ${bd2}) unless explicitly allowed in VALID_PAIRS.`);\n          valid = false;\n          pairErrorFound = true;\n        }\n\n        // If no specific group error was found, and it's not in VALID_PAIRS, then it's generally not supported.\n        if (!pairErrorFound) {\n          errors.push(`The combination of '${bd1}' and '${bd2}' is not supported by Meta.`);\n          valid = false;\n          // pairErrorFound = true; // Not strictly needed as it's the last check for this path\n        }\n      }\n    }\n  }\n  return {\n    valid,\n    errors\n  };\n};\n\n// Check if a breakdown should be disabled based on current selections\nexport const isBreakdownDisabled = (breakdownId, selectedFields, selectedBreakdowns) => {\n  // If this breakdown is already selected, it's not disabled (can always be deselected)\n  if (selectedBreakdowns[breakdownId]) {\n    return false;\n  }\n  const hasAction = Object.entries(selectedFields).some(([k, v]) => v && ACTION_METRICS.includes(k));\n  if (hasAction) {\n    // allow at most ONE extra breakdown and it must be in ACTION_TYPE_ALLOWED_BREAKDOWNS\n    if (!ACTION_TYPE_ALLOWED_BREAKDOWNS.includes(breakdownId)) return true;\n    if (Object.values(selectedBreakdowns).filter(Boolean).length >= 1) return true;\n  }\n  const selectedBreakdownIds = Object.entries(selectedBreakdowns).filter(([_, isSelected]) => isSelected).map(([id, _]) => id).sort(); // enforce order deterministically\n\n  // treat os_ios/os_and as mutually exclusive\n  const hasVirtualOSSelected = selectedBreakdownIds.some(isVirtualOS);\n  if (hasVirtualOSSelected && isVirtualOS(breakdownId) && !selectedBreakdownIds.includes(breakdownId)) return true; // can't pick both, unless it's to deselect current\n\n  // Rule 1: Limit to max 2 breakdowns\n  if (selectedBreakdownIds.length >= 2) {\n    return true;\n  }\n\n  // Check if any action metrics are selected - this implicitly adds action_type as a breakdown\n  const hasActionMetrics = Object.entries(selectedFields).some(([field, isSelected]) => isSelected && ACTION_METRICS.includes(field));\n\n  // When action metrics are selected (which adds implicit action_type breakdown)\n  if (hasActionMetrics) {\n    // Only allow breakdowns specifically allowed with action_type\n    if (!ACTION_TYPE_ALLOWED_BREAKDOWNS.includes(breakdownId)) return true;\n    if (selectedBreakdownIds.length >= 1) return true;\n  }\n\n  // No restrictions if nothing is selected yet\n  if (selectedBreakdownIds.length === 0) {\n    return false;\n  }\n  const currentBreakdown = selectedBreakdownIds[0];\n\n  // Rule 2: Check \"pick-only-one\" groups\n  if (GEOGRAPHY_GROUP.includes(currentBreakdown) && GEOGRAPHY_GROUP.includes(breakdownId) || DEVICE_GROUP.includes(currentBreakdown) && DEVICE_GROUP.includes(breakdownId) || PLACEMENT_GROUP.includes(currentBreakdown) && PLACEMENT_GROUP.includes(breakdownId) || TIME_GROUP.includes(currentBreakdown) && TIME_GROUP.includes(breakdownId) || ASSET_GROUP.includes(currentBreakdown) && ASSET_GROUP.includes(breakdownId)) {\n    return true;\n  }\n\n  // Rule 3: Hourly breakdowns must stand alone\n  if (TIME_GROUP.includes(currentBreakdown) && !TIME_GROUP.includes(breakdownId) || TIME_GROUP.includes(breakdownId) && !TIME_GROUP.includes(currentBreakdown)) {\n    return true;\n  }\n\n  // Rule 4: Check if the pair is in the known-good list\n  const isPairValid = VALID_PAIRS.some(pair => pair[0] === currentBreakdown && pair[1] === breakdownId || pair[1] === currentBreakdown && pair[0] === breakdownId);\n\n  // Return whether this pair is valid for selection\n  return !isPairValid;\n};\n\n// Get tooltip message explaining why a breakdown is disabled\nexport const getDisabledTooltip = (breakdownId, selectedFields, selectedBreakdowns) => {\n  // Create a simulated state as if this breakdown was selected\n  const simulatedBreakdowns = {\n    ...selectedBreakdowns\n  };\n  simulatedBreakdowns[breakdownId] = true;\n\n  // Validate the simulated combo\n  const validation = validateMetaBreakdownCombo(selectedFields, simulatedBreakdowns);\n\n  // Return the first error message if invalid\n  if (!validation.valid) {\n    return validation.errors[0];\n  }\n  return \"\"; // Should not happen as isBreakdownDisabled would have returned false\n};\n\n// Get the comma-separated list of selected fields\nexport const getSelectedFieldsString = selectedFields => {\n  return Object.entries(selectedFields).filter(([_, isSelected]) => isSelected).map(([fieldId, _]) => fieldId).join(',');\n};\n\n// Get the comma-separated list of selected breakdowns\nexport const getSelectedBreakdownsString = selectedBreakdowns => {\n  return Object.entries(selectedBreakdowns).filter(([_, isSelected]) => isSelected).map(([breakdownId, _]) => breakdownId).join(',');\n};\n\n// Build API parameters for Meta requests\nexport const buildApiParams = (startDateInput, endDateInput, incrementInput, selectedFields, selectedBreakdowns, actionBreakdowns = null) => {\n  const fields = Object.entries(selectedFields).filter(([, v]) => v).map(([k]) => k).join(',');\n  const active = Object.entries(selectedBreakdowns).filter(([, v]) => v).map(([k]) => k);\n  const hasIOS = active.includes('os_ios');\n  const hasAND = active.includes('os_and');\n\n  // real breakdown list we will send\n  const breakdowns = active.filter(id => !isVirtualOS(id));\n\n  // ensure impression_device is included if a virtual OS was picked\n  if ((hasIOS || hasAND) && !breakdowns.includes('impression_device')) breakdowns.push('impression_device');\n  const params = {\n    start_date: startDateInput,\n    end_date: endDateInput,\n    time_increment: parseInt(incrementInput, 10) || 1,\n    fields\n  };\n  if (breakdowns.length) params.breakdowns = breakdowns.join(',');\n\n  // Add action_breakdowns parameter if provided\n  if (actionBreakdowns) {\n    params.action_breakdowns = actionBreakdowns;\n  }\n\n  // add filtering for virtual OS\n  if (hasIOS || hasAND) {\n    const key = hasIOS ? 'os_ios' : 'os_and';\n    params.filtering = JSON.stringify([{\n      field: 'impression_device',\n      operator: 'IN',\n      value: VIRTUAL_OS_MAP[key].filterValues\n    }]);\n  }\n  return params;\n};\n\n// Validate date format (YYYY-MM-DD)\nexport const isValidDate = dateStr => {\n  const regex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!regex.test(dateStr)) return false;\n  const [year, month, day] = dateStr.split('-').map(Number);\n  const date = new Date(year, month - 1, day);\n  return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;\n};","map":{"version":3,"names":["ACTION_METRICS","ACTION_TYPE_ALLOWED_BREAKDOWNS","GEOGRAPHY_GROUP","DEVICE_GROUP","PLACEMENT_GROUP","TIME_GROUP","ASSET_GROUP","DELIVERY_ONLY_FIELDS","VALID_PAIRS","VIRTUAL_OS_MAP","isVirtualOS","id","compactObject","obj","Object","fromEntries","entries","filter","_","v","validateMetaBreakdownCombo","fields","breakdowns","selectedFieldIds","isSelected","map","selectedBreakdownIds","sort","hasActionMetrics","some","field","includes","errors","valid","length","push","join","bd1","bd2","isDeliveryOnlyRequest","every","isPairInValidPairs","pair","pairErrorFound","isBreakdownDisabled","breakdownId","selectedFields","selectedBreakdowns","hasAction","k","values","Boolean","hasVirtualOSSelected","currentBreakdown","isPairValid","getDisabledTooltip","simulatedBreakdowns","validation","getSelectedFieldsString","fieldId","getSelectedBreakdownsString","buildApiParams","startDateInput","endDateInput","incrementInput","actionBreakdowns","active","hasIOS","hasAND","params","start_date","end_date","time_increment","parseInt","action_breakdowns","key","filtering","JSON","stringify","operator","value","filterValues","isValidDate","dateStr","regex","test","year","month","day","split","Number","date","Date","getFullYear","getMonth","getDate"],"sources":["/Users/joshuakaufman/untitled folder 3/orchestrator/dashboard/client/src/components/meta/utils/metaApiUtils.js"],"sourcesContent":["import {\n  ACTION_METRICS,\n  ACTION_TYPE_ALLOWED_BREAKDOWNS,\n  GEOGRAPHY_GROUP,\n  DEVICE_GROUP,\n  PLACEMENT_GROUP,\n  TIME_GROUP,\n  ASSET_GROUP,\n  DELIVERY_ONLY_FIELDS,\n  VALID_PAIRS,\n  VIRTUAL_OS_MAP\n} from './metaConstants';\n\n// Helper to recognise a virtual OS ID\nexport const isVirtualOS = id => id === 'os_ios' || id === 'os_and';\n\n// Helper to remove falsy entries from an object before storing to localStorage\nexport const compactObject = (obj) =>\n  Object.fromEntries(Object.entries(obj).filter(([_, v]) => v));\n\n// Validate combinations of selected fields and breakdowns\nexport const validateMetaBreakdownCombo = (fields, breakdowns) => {\n  const selectedFieldIds = Object.entries(fields)\n    .filter(([_, isSelected]) => isSelected)\n    .map(([id, _]) => id);\n    \n  const selectedBreakdownIds = Object.entries(breakdowns)\n    .filter(([_, isSelected]) => isSelected)\n    .map(([id, _]) => id)\n    .sort();\n  \n  const hasActionMetrics = selectedFieldIds.some(field => ACTION_METRICS.includes(field));\n  const errors = [];\n  let valid = true;\n  \n  // Check breakdown limit\n  if (selectedBreakdownIds.length > 2) {\n    errors.push(\"Maximum of 2 breakdowns allowed\");\n    valid = false;\n  }\n  \n  // Check action metric restrictions\n  if (hasActionMetrics) {\n    if (selectedBreakdownIds.length > 1) {\n      errors.push(\"When using action metrics, you can select at most 1 breakdown because Meta adds 'action_type' as an implicit breakdown\");\n      valid = false;\n    }\n    \n    if (selectedBreakdownIds.length === 1 && !ACTION_TYPE_ALLOWED_BREAKDOWNS.includes(selectedBreakdownIds[0])) {\n      errors.push(\n        `'${selectedBreakdownIds[0]}' is no longer valid. Use one of: ` +\n        ACTION_TYPE_ALLOWED_BREAKDOWNS.join(', ')\n      );\n      valid = false;\n    }\n  }\n  \n  // Check group restrictions if we have multiple breakdowns\n  if (selectedBreakdownIds.length === 2) {\n    const [bd1, bd2] = selectedBreakdownIds;\n    \n    const isDeliveryOnlyRequest = selectedFieldIds.length > 0 && \n      selectedFieldIds.every(field => DELIVERY_ONLY_FIELDS.includes(field));\n\n    const isPairInValidPairs = VALID_PAIRS.some(pair => \n      (pair[0] === bd1 && pair[1] === bd2) || \n      (pair[1] === bd1 && pair[0] === bd2)\n    );\n\n    let pairErrorFound = false; // Flag to prevent multiple errors for the same pair\n\n    // Hourly breakdowns must always stand alone\n    if (TIME_GROUP.includes(bd1) || TIME_GROUP.includes(bd2)) {\n      errors.push(\"Hourly breakdowns must stand alone\");\n      valid = false;\n      pairErrorFound = true;\n    }\n\n    if (!pairErrorFound) {\n      if (isPairInValidPairs) {\n        // Pair is in VALID_PAIRS. No further same-group or general validity check needed for these.\n        // Hourly check already done.\n      } else {\n        // Pair is NOT in VALID_PAIRS. Check for same-group violations.\n        if (\n          (GEOGRAPHY_GROUP.includes(bd1) && GEOGRAPHY_GROUP.includes(bd2)) ||\n          (DEVICE_GROUP.includes(bd1) && DEVICE_GROUP.includes(bd2)) ||\n          (PLACEMENT_GROUP.includes(bd1) && PLACEMENT_GROUP.includes(bd2)) ||\n          // ASSET_GROUP has a special condition with isDeliveryOnlyRequest\n          (!isDeliveryOnlyRequest && ASSET_GROUP.includes(bd1) && ASSET_GROUP.includes(bd2))\n          // TIME_GROUP is implicitly handled by the hourly check above if they are in the same group\n        ) {\n          errors.push(`Cannot select multiple breakdowns from the same group (${bd1}, ${bd2}) unless explicitly allowed in VALID_PAIRS.`);\n          valid = false;\n          pairErrorFound = true;\n        }\n\n        // If no specific group error was found, and it's not in VALID_PAIRS, then it's generally not supported.\n        if (!pairErrorFound) {\n          errors.push(`The combination of '${bd1}' and '${bd2}' is not supported by Meta.`);\n          valid = false;\n          // pairErrorFound = true; // Not strictly needed as it's the last check for this path\n        }\n      }\n    }\n  }\n  \n  return { valid, errors };\n};\n\n// Check if a breakdown should be disabled based on current selections\nexport const isBreakdownDisabled = (breakdownId, selectedFields, selectedBreakdowns) => {\n  // If this breakdown is already selected, it's not disabled (can always be deselected)\n  if (selectedBreakdowns[breakdownId]) {\n    return false;\n  }\n  \n  const hasAction = Object.entries(selectedFields)\n    .some(([k,v]) => v && ACTION_METRICS.includes(k));\n  if (hasAction) {\n    // allow at most ONE extra breakdown and it must be in ACTION_TYPE_ALLOWED_BREAKDOWNS\n    if (!ACTION_TYPE_ALLOWED_BREAKDOWNS.includes(breakdownId)) return true;\n    if (Object.values(selectedBreakdowns).filter(Boolean).length >= 1) return true;\n  }\n  \n  const selectedBreakdownIds = Object.entries(selectedBreakdowns)\n    .filter(([_, isSelected]) => isSelected)\n    .map(([id, _]) => id)\n    .sort(); // enforce order deterministically\n\n  // treat os_ios/os_and as mutually exclusive\n  const hasVirtualOSSelected = selectedBreakdownIds.some(isVirtualOS);\n  if (hasVirtualOSSelected && isVirtualOS(breakdownId) && !selectedBreakdownIds.includes(breakdownId)) return true; // can't pick both, unless it's to deselect current\n\n  // Rule 1: Limit to max 2 breakdowns\n  if (selectedBreakdownIds.length >= 2) {\n    return true;\n  }\n\n  // Check if any action metrics are selected - this implicitly adds action_type as a breakdown\n  const hasActionMetrics = Object.entries(selectedFields)\n    .some(([field, isSelected]) => isSelected && ACTION_METRICS.includes(field));\n  \n  // When action metrics are selected (which adds implicit action_type breakdown)\n  if (hasActionMetrics) {\n    // Only allow breakdowns specifically allowed with action_type\n    if (!ACTION_TYPE_ALLOWED_BREAKDOWNS.includes(breakdownId)) return true;\n    if (selectedBreakdownIds.length >= 1) return true;\n  }\n\n  // No restrictions if nothing is selected yet\n  if (selectedBreakdownIds.length === 0) {\n    return false;\n  }\n\n  const currentBreakdown = selectedBreakdownIds[0];\n  \n  // Rule 2: Check \"pick-only-one\" groups\n  if (\n    (GEOGRAPHY_GROUP.includes(currentBreakdown) && GEOGRAPHY_GROUP.includes(breakdownId)) ||\n    (DEVICE_GROUP.includes(currentBreakdown) && DEVICE_GROUP.includes(breakdownId)) ||\n    (PLACEMENT_GROUP.includes(currentBreakdown) && PLACEMENT_GROUP.includes(breakdownId)) ||\n    (TIME_GROUP.includes(currentBreakdown) && TIME_GROUP.includes(breakdownId)) ||\n    (ASSET_GROUP.includes(currentBreakdown) && ASSET_GROUP.includes(breakdownId))\n  ) {\n    return true;\n  }\n\n  // Rule 3: Hourly breakdowns must stand alone\n  if (\n    (TIME_GROUP.includes(currentBreakdown) && !TIME_GROUP.includes(breakdownId)) ||\n    (TIME_GROUP.includes(breakdownId) && !TIME_GROUP.includes(currentBreakdown))\n  ) {\n    return true;\n  }\n\n  // Rule 4: Check if the pair is in the known-good list\n  const isPairValid = VALID_PAIRS.some(pair => \n    (pair[0] === currentBreakdown && pair[1] === breakdownId) || \n    (pair[1] === currentBreakdown && pair[0] === breakdownId)\n  );\n  \n  // Return whether this pair is valid for selection\n  return !isPairValid;\n};\n\n// Get tooltip message explaining why a breakdown is disabled\nexport const getDisabledTooltip = (breakdownId, selectedFields, selectedBreakdowns) => {\n  // Create a simulated state as if this breakdown was selected\n  const simulatedBreakdowns = { ...selectedBreakdowns };\n  simulatedBreakdowns[breakdownId] = true;\n  \n  // Validate the simulated combo\n  const validation = validateMetaBreakdownCombo(selectedFields, simulatedBreakdowns);\n  \n  // Return the first error message if invalid\n  if (!validation.valid) {\n    return validation.errors[0]; \n  }\n  \n  return \"\"; // Should not happen as isBreakdownDisabled would have returned false\n};\n\n// Get the comma-separated list of selected fields\nexport const getSelectedFieldsString = (selectedFields) => {\n  return Object.entries(selectedFields)\n    .filter(([_, isSelected]) => isSelected)\n    .map(([fieldId, _]) => fieldId)\n    .join(',');\n};\n\n// Get the comma-separated list of selected breakdowns\nexport const getSelectedBreakdownsString = (selectedBreakdowns) => {\n  return Object.entries(selectedBreakdowns)\n    .filter(([_, isSelected]) => isSelected)\n    .map(([breakdownId, _]) => breakdownId)\n    .join(',');\n};\n\n// Build API parameters for Meta requests\nexport const buildApiParams = (startDateInput, endDateInput, incrementInput, selectedFields, selectedBreakdowns, actionBreakdowns = null) => {\n  const fields = Object.entries(selectedFields)\n                  .filter(([,v]) => v).map(([k]) => k).join(',');\n\n  const active = Object.entries(selectedBreakdowns)\n                  .filter(([,v]) => v).map(([k]) => k);\n\n  const hasIOS  = active.includes('os_ios');\n  const hasAND  = active.includes('os_and');\n\n  // real breakdown list we will send\n  const breakdowns = active.filter(id => !isVirtualOS(id));\n\n  // ensure impression_device is included if a virtual OS was picked\n  if ((hasIOS || hasAND) && !breakdowns.includes('impression_device'))\n      breakdowns.push('impression_device');\n\n  const params = {\n    start_date: startDateInput,\n    end_date:   endDateInput,\n    time_increment: parseInt(incrementInput,10) || 1,\n    fields\n  };\n\n  if (breakdowns.length) params.breakdowns = breakdowns.join(',');\n\n  // Add action_breakdowns parameter if provided\n  if (actionBreakdowns) {\n    params.action_breakdowns = actionBreakdowns;\n  }\n\n  // add filtering for virtual OS\n  if (hasIOS || hasAND) {\n    const key  = hasIOS ? 'os_ios' : 'os_and';\n    params.filtering = JSON.stringify([{\n      field: 'impression_device',\n      operator: 'IN',\n      value: VIRTUAL_OS_MAP[key].filterValues\n    }]);\n  }\n\n  return params;\n};\n\n// Validate date format (YYYY-MM-DD)\nexport const isValidDate = (dateStr) => {\n  const regex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!regex.test(dateStr)) return false;\n  \n  const [year, month, day] = dateStr.split('-').map(Number);\n  const date = new Date(year, month - 1, day);\n  \n  return date.getFullYear() === year && \n         date.getMonth() === month - 1 && \n         date.getDate() === day;\n}; "],"mappings":"AAAA,SACEA,cAAc,EACdC,8BAA8B,EAC9BC,eAAe,EACfC,YAAY,EACZC,eAAe,EACfC,UAAU,EACVC,WAAW,EACXC,oBAAoB,EACpBC,WAAW,EACXC,cAAc,QACT,iBAAiB;;AAExB;AACA,OAAO,MAAMC,WAAW,GAAGC,EAAE,IAAIA,EAAE,KAAK,QAAQ,IAAIA,EAAE,KAAK,QAAQ;;AAEnE;AACA,OAAO,MAAMC,aAAa,GAAIC,GAAG,IAC/BC,MAAM,CAACC,WAAW,CAACD,MAAM,CAACE,OAAO,CAACH,GAAG,CAAC,CAACI,MAAM,CAAC,CAAC,CAACC,CAAC,EAAEC,CAAC,CAAC,KAAKA,CAAC,CAAC,CAAC;;AAE/D;AACA,OAAO,MAAMC,0BAA0B,GAAGA,CAACC,MAAM,EAAEC,UAAU,KAAK;EAChE,MAAMC,gBAAgB,GAAGT,MAAM,CAACE,OAAO,CAACK,MAAM,CAAC,CAC5CJ,MAAM,CAAC,CAAC,CAACC,CAAC,EAAEM,UAAU,CAAC,KAAKA,UAAU,CAAC,CACvCC,GAAG,CAAC,CAAC,CAACd,EAAE,EAAEO,CAAC,CAAC,KAAKP,EAAE,CAAC;EAEvB,MAAMe,oBAAoB,GAAGZ,MAAM,CAACE,OAAO,CAACM,UAAU,CAAC,CACpDL,MAAM,CAAC,CAAC,CAACC,CAAC,EAAEM,UAAU,CAAC,KAAKA,UAAU,CAAC,CACvCC,GAAG,CAAC,CAAC,CAACd,EAAE,EAAEO,CAAC,CAAC,KAAKP,EAAE,CAAC,CACpBgB,IAAI,CAAC,CAAC;EAET,MAAMC,gBAAgB,GAAGL,gBAAgB,CAACM,IAAI,CAACC,KAAK,IAAI9B,cAAc,CAAC+B,QAAQ,CAACD,KAAK,CAAC,CAAC;EACvF,MAAME,MAAM,GAAG,EAAE;EACjB,IAAIC,KAAK,GAAG,IAAI;;EAEhB;EACA,IAAIP,oBAAoB,CAACQ,MAAM,GAAG,CAAC,EAAE;IACnCF,MAAM,CAACG,IAAI,CAAC,iCAAiC,CAAC;IAC9CF,KAAK,GAAG,KAAK;EACf;;EAEA;EACA,IAAIL,gBAAgB,EAAE;IACpB,IAAIF,oBAAoB,CAACQ,MAAM,GAAG,CAAC,EAAE;MACnCF,MAAM,CAACG,IAAI,CAAC,wHAAwH,CAAC;MACrIF,KAAK,GAAG,KAAK;IACf;IAEA,IAAIP,oBAAoB,CAACQ,MAAM,KAAK,CAAC,IAAI,CAACjC,8BAA8B,CAAC8B,QAAQ,CAACL,oBAAoB,CAAC,CAAC,CAAC,CAAC,EAAE;MAC1GM,MAAM,CAACG,IAAI,CACT,IAAIT,oBAAoB,CAAC,CAAC,CAAC,oCAAoC,GAC/DzB,8BAA8B,CAACmC,IAAI,CAAC,IAAI,CAC1C,CAAC;MACDH,KAAK,GAAG,KAAK;IACf;EACF;;EAEA;EACA,IAAIP,oBAAoB,CAACQ,MAAM,KAAK,CAAC,EAAE;IACrC,MAAM,CAACG,GAAG,EAAEC,GAAG,CAAC,GAAGZ,oBAAoB;IAEvC,MAAMa,qBAAqB,GAAGhB,gBAAgB,CAACW,MAAM,GAAG,CAAC,IACvDX,gBAAgB,CAACiB,KAAK,CAACV,KAAK,IAAIvB,oBAAoB,CAACwB,QAAQ,CAACD,KAAK,CAAC,CAAC;IAEvE,MAAMW,kBAAkB,GAAGjC,WAAW,CAACqB,IAAI,CAACa,IAAI,IAC7CA,IAAI,CAAC,CAAC,CAAC,KAAKL,GAAG,IAAIK,IAAI,CAAC,CAAC,CAAC,KAAKJ,GAAG,IAClCI,IAAI,CAAC,CAAC,CAAC,KAAKL,GAAG,IAAIK,IAAI,CAAC,CAAC,CAAC,KAAKJ,GAClC,CAAC;IAED,IAAIK,cAAc,GAAG,KAAK,CAAC,CAAC;;IAE5B;IACA,IAAItC,UAAU,CAAC0B,QAAQ,CAACM,GAAG,CAAC,IAAIhC,UAAU,CAAC0B,QAAQ,CAACO,GAAG,CAAC,EAAE;MACxDN,MAAM,CAACG,IAAI,CAAC,oCAAoC,CAAC;MACjDF,KAAK,GAAG,KAAK;MACbU,cAAc,GAAG,IAAI;IACvB;IAEA,IAAI,CAACA,cAAc,EAAE;MACnB,IAAIF,kBAAkB,EAAE;QACtB;QACA;MAAA,CACD,MAAM;QACL;QACA,IACGvC,eAAe,CAAC6B,QAAQ,CAACM,GAAG,CAAC,IAAInC,eAAe,CAAC6B,QAAQ,CAACO,GAAG,CAAC,IAC9DnC,YAAY,CAAC4B,QAAQ,CAACM,GAAG,CAAC,IAAIlC,YAAY,CAAC4B,QAAQ,CAACO,GAAG,CAAE,IACzDlC,eAAe,CAAC2B,QAAQ,CAACM,GAAG,CAAC,IAAIjC,eAAe,CAAC2B,QAAQ,CAACO,GAAG,CAAE;QAChE;QACC,CAACC,qBAAqB,IAAIjC,WAAW,CAACyB,QAAQ,CAACM,GAAG,CAAC,IAAI/B,WAAW,CAACyB,QAAQ,CAACO,GAAG;QAChF;QAAA,EACA;UACAN,MAAM,CAACG,IAAI,CAAC,0DAA0DE,GAAG,KAAKC,GAAG,6CAA6C,CAAC;UAC/HL,KAAK,GAAG,KAAK;UACbU,cAAc,GAAG,IAAI;QACvB;;QAEA;QACA,IAAI,CAACA,cAAc,EAAE;UACnBX,MAAM,CAACG,IAAI,CAAC,uBAAuBE,GAAG,UAAUC,GAAG,6BAA6B,CAAC;UACjFL,KAAK,GAAG,KAAK;UACb;QACF;MACF;IACF;EACF;EAEA,OAAO;IAAEA,KAAK;IAAED;EAAO,CAAC;AAC1B,CAAC;;AAED;AACA,OAAO,MAAMY,mBAAmB,GAAGA,CAACC,WAAW,EAAEC,cAAc,EAAEC,kBAAkB,KAAK;EACtF;EACA,IAAIA,kBAAkB,CAACF,WAAW,CAAC,EAAE;IACnC,OAAO,KAAK;EACd;EAEA,MAAMG,SAAS,GAAGlC,MAAM,CAACE,OAAO,CAAC8B,cAAc,CAAC,CAC7CjB,IAAI,CAAC,CAAC,CAACoB,CAAC,EAAC9B,CAAC,CAAC,KAAKA,CAAC,IAAInB,cAAc,CAAC+B,QAAQ,CAACkB,CAAC,CAAC,CAAC;EACnD,IAAID,SAAS,EAAE;IACb;IACA,IAAI,CAAC/C,8BAA8B,CAAC8B,QAAQ,CAACc,WAAW,CAAC,EAAE,OAAO,IAAI;IACtE,IAAI/B,MAAM,CAACoC,MAAM,CAACH,kBAAkB,CAAC,CAAC9B,MAAM,CAACkC,OAAO,CAAC,CAACjB,MAAM,IAAI,CAAC,EAAE,OAAO,IAAI;EAChF;EAEA,MAAMR,oBAAoB,GAAGZ,MAAM,CAACE,OAAO,CAAC+B,kBAAkB,CAAC,CAC5D9B,MAAM,CAAC,CAAC,CAACC,CAAC,EAAEM,UAAU,CAAC,KAAKA,UAAU,CAAC,CACvCC,GAAG,CAAC,CAAC,CAACd,EAAE,EAAEO,CAAC,CAAC,KAAKP,EAAE,CAAC,CACpBgB,IAAI,CAAC,CAAC,CAAC,CAAC;;EAEX;EACA,MAAMyB,oBAAoB,GAAG1B,oBAAoB,CAACG,IAAI,CAACnB,WAAW,CAAC;EACnE,IAAI0C,oBAAoB,IAAI1C,WAAW,CAACmC,WAAW,CAAC,IAAI,CAACnB,oBAAoB,CAACK,QAAQ,CAACc,WAAW,CAAC,EAAE,OAAO,IAAI,CAAC,CAAC;;EAElH;EACA,IAAInB,oBAAoB,CAACQ,MAAM,IAAI,CAAC,EAAE;IACpC,OAAO,IAAI;EACb;;EAEA;EACA,MAAMN,gBAAgB,GAAGd,MAAM,CAACE,OAAO,CAAC8B,cAAc,CAAC,CACpDjB,IAAI,CAAC,CAAC,CAACC,KAAK,EAAEN,UAAU,CAAC,KAAKA,UAAU,IAAIxB,cAAc,CAAC+B,QAAQ,CAACD,KAAK,CAAC,CAAC;;EAE9E;EACA,IAAIF,gBAAgB,EAAE;IACpB;IACA,IAAI,CAAC3B,8BAA8B,CAAC8B,QAAQ,CAACc,WAAW,CAAC,EAAE,OAAO,IAAI;IACtE,IAAInB,oBAAoB,CAACQ,MAAM,IAAI,CAAC,EAAE,OAAO,IAAI;EACnD;;EAEA;EACA,IAAIR,oBAAoB,CAACQ,MAAM,KAAK,CAAC,EAAE;IACrC,OAAO,KAAK;EACd;EAEA,MAAMmB,gBAAgB,GAAG3B,oBAAoB,CAAC,CAAC,CAAC;;EAEhD;EACA,IACGxB,eAAe,CAAC6B,QAAQ,CAACsB,gBAAgB,CAAC,IAAInD,eAAe,CAAC6B,QAAQ,CAACc,WAAW,CAAC,IACnF1C,YAAY,CAAC4B,QAAQ,CAACsB,gBAAgB,CAAC,IAAIlD,YAAY,CAAC4B,QAAQ,CAACc,WAAW,CAAE,IAC9EzC,eAAe,CAAC2B,QAAQ,CAACsB,gBAAgB,CAAC,IAAIjD,eAAe,CAAC2B,QAAQ,CAACc,WAAW,CAAE,IACpFxC,UAAU,CAAC0B,QAAQ,CAACsB,gBAAgB,CAAC,IAAIhD,UAAU,CAAC0B,QAAQ,CAACc,WAAW,CAAE,IAC1EvC,WAAW,CAACyB,QAAQ,CAACsB,gBAAgB,CAAC,IAAI/C,WAAW,CAACyB,QAAQ,CAACc,WAAW,CAAE,EAC7E;IACA,OAAO,IAAI;EACb;;EAEA;EACA,IACGxC,UAAU,CAAC0B,QAAQ,CAACsB,gBAAgB,CAAC,IAAI,CAAChD,UAAU,CAAC0B,QAAQ,CAACc,WAAW,CAAC,IAC1ExC,UAAU,CAAC0B,QAAQ,CAACc,WAAW,CAAC,IAAI,CAACxC,UAAU,CAAC0B,QAAQ,CAACsB,gBAAgB,CAAE,EAC5E;IACA,OAAO,IAAI;EACb;;EAEA;EACA,MAAMC,WAAW,GAAG9C,WAAW,CAACqB,IAAI,CAACa,IAAI,IACtCA,IAAI,CAAC,CAAC,CAAC,KAAKW,gBAAgB,IAAIX,IAAI,CAAC,CAAC,CAAC,KAAKG,WAAW,IACvDH,IAAI,CAAC,CAAC,CAAC,KAAKW,gBAAgB,IAAIX,IAAI,CAAC,CAAC,CAAC,KAAKG,WAC/C,CAAC;;EAED;EACA,OAAO,CAACS,WAAW;AACrB,CAAC;;AAED;AACA,OAAO,MAAMC,kBAAkB,GAAGA,CAACV,WAAW,EAAEC,cAAc,EAAEC,kBAAkB,KAAK;EACrF;EACA,MAAMS,mBAAmB,GAAG;IAAE,GAAGT;EAAmB,CAAC;EACrDS,mBAAmB,CAACX,WAAW,CAAC,GAAG,IAAI;;EAEvC;EACA,MAAMY,UAAU,GAAGrC,0BAA0B,CAAC0B,cAAc,EAAEU,mBAAmB,CAAC;;EAElF;EACA,IAAI,CAACC,UAAU,CAACxB,KAAK,EAAE;IACrB,OAAOwB,UAAU,CAACzB,MAAM,CAAC,CAAC,CAAC;EAC7B;EAEA,OAAO,EAAE,CAAC,CAAC;AACb,CAAC;;AAED;AACA,OAAO,MAAM0B,uBAAuB,GAAIZ,cAAc,IAAK;EACzD,OAAOhC,MAAM,CAACE,OAAO,CAAC8B,cAAc,CAAC,CAClC7B,MAAM,CAAC,CAAC,CAACC,CAAC,EAAEM,UAAU,CAAC,KAAKA,UAAU,CAAC,CACvCC,GAAG,CAAC,CAAC,CAACkC,OAAO,EAAEzC,CAAC,CAAC,KAAKyC,OAAO,CAAC,CAC9BvB,IAAI,CAAC,GAAG,CAAC;AACd,CAAC;;AAED;AACA,OAAO,MAAMwB,2BAA2B,GAAIb,kBAAkB,IAAK;EACjE,OAAOjC,MAAM,CAACE,OAAO,CAAC+B,kBAAkB,CAAC,CACtC9B,MAAM,CAAC,CAAC,CAACC,CAAC,EAAEM,UAAU,CAAC,KAAKA,UAAU,CAAC,CACvCC,GAAG,CAAC,CAAC,CAACoB,WAAW,EAAE3B,CAAC,CAAC,KAAK2B,WAAW,CAAC,CACtCT,IAAI,CAAC,GAAG,CAAC;AACd,CAAC;;AAED;AACA,OAAO,MAAMyB,cAAc,GAAGA,CAACC,cAAc,EAAEC,YAAY,EAAEC,cAAc,EAAElB,cAAc,EAAEC,kBAAkB,EAAEkB,gBAAgB,GAAG,IAAI,KAAK;EAC3I,MAAM5C,MAAM,GAAGP,MAAM,CAACE,OAAO,CAAC8B,cAAc,CAAC,CAC5B7B,MAAM,CAAC,CAAC,GAAEE,CAAC,CAAC,KAAKA,CAAC,CAAC,CAACM,GAAG,CAAC,CAAC,CAACwB,CAAC,CAAC,KAAKA,CAAC,CAAC,CAACb,IAAI,CAAC,GAAG,CAAC;EAE9D,MAAM8B,MAAM,GAAGpD,MAAM,CAACE,OAAO,CAAC+B,kBAAkB,CAAC,CAChC9B,MAAM,CAAC,CAAC,GAAEE,CAAC,CAAC,KAAKA,CAAC,CAAC,CAACM,GAAG,CAAC,CAAC,CAACwB,CAAC,CAAC,KAAKA,CAAC,CAAC;EAEpD,MAAMkB,MAAM,GAAID,MAAM,CAACnC,QAAQ,CAAC,QAAQ,CAAC;EACzC,MAAMqC,MAAM,GAAIF,MAAM,CAACnC,QAAQ,CAAC,QAAQ,CAAC;;EAEzC;EACA,MAAMT,UAAU,GAAG4C,MAAM,CAACjD,MAAM,CAACN,EAAE,IAAI,CAACD,WAAW,CAACC,EAAE,CAAC,CAAC;;EAExD;EACA,IAAI,CAACwD,MAAM,IAAIC,MAAM,KAAK,CAAC9C,UAAU,CAACS,QAAQ,CAAC,mBAAmB,CAAC,EAC/DT,UAAU,CAACa,IAAI,CAAC,mBAAmB,CAAC;EAExC,MAAMkC,MAAM,GAAG;IACbC,UAAU,EAAER,cAAc;IAC1BS,QAAQ,EAAIR,YAAY;IACxBS,cAAc,EAAEC,QAAQ,CAACT,cAAc,EAAC,EAAE,CAAC,IAAI,CAAC;IAChD3C;EACF,CAAC;EAED,IAAIC,UAAU,CAACY,MAAM,EAAEmC,MAAM,CAAC/C,UAAU,GAAGA,UAAU,CAACc,IAAI,CAAC,GAAG,CAAC;;EAE/D;EACA,IAAI6B,gBAAgB,EAAE;IACpBI,MAAM,CAACK,iBAAiB,GAAGT,gBAAgB;EAC7C;;EAEA;EACA,IAAIE,MAAM,IAAIC,MAAM,EAAE;IACpB,MAAMO,GAAG,GAAIR,MAAM,GAAG,QAAQ,GAAG,QAAQ;IACzCE,MAAM,CAACO,SAAS,GAAGC,IAAI,CAACC,SAAS,CAAC,CAAC;MACjChD,KAAK,EAAE,mBAAmB;MAC1BiD,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAEvE,cAAc,CAACkE,GAAG,CAAC,CAACM;IAC7B,CAAC,CAAC,CAAC;EACL;EAEA,OAAOZ,MAAM;AACf,CAAC;;AAED;AACA,OAAO,MAAMa,WAAW,GAAIC,OAAO,IAAK;EACtC,MAAMC,KAAK,GAAG,qBAAqB;EACnC,IAAI,CAACA,KAAK,CAACC,IAAI,CAACF,OAAO,CAAC,EAAE,OAAO,KAAK;EAEtC,MAAM,CAACG,IAAI,EAAEC,KAAK,EAAEC,GAAG,CAAC,GAAGL,OAAO,CAACM,KAAK,CAAC,GAAG,CAAC,CAAChE,GAAG,CAACiE,MAAM,CAAC;EACzD,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAACN,IAAI,EAAEC,KAAK,GAAG,CAAC,EAAEC,GAAG,CAAC;EAE3C,OAAOG,IAAI,CAACE,WAAW,CAAC,CAAC,KAAKP,IAAI,IAC3BK,IAAI,CAACG,QAAQ,CAAC,CAAC,KAAKP,KAAK,GAAG,CAAC,IAC7BI,IAAI,CAACI,OAAO,CAAC,CAAC,KAAKP,GAAG;AAC/B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}